/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   clean_data_2.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

void	ft_free_str_array(char **arr)
{
	int	i;

	if (!arr)
		return ;
	i = 0;
	while (arr[i])
	{
		free(arr[i]);
		i++;
	}
	free(arr);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   clean_data.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

static void	free_one_object(t_object *obj)
{
	if (!obj)
		return ;
	if (obj->material)
	{
		if (obj->material->color_img)
		{
			mlx_delete_texture(obj->material->color_img);
			obj->material->color_img = NULL;
		}
		if (obj->material->texture_img)
		{
			mlx_delete_texture(obj->material->texture_img);
			obj->material->texture_img = NULL;
		}
		free(obj->material);
		obj->material = NULL;
	}
	if (obj->data)
	{
		free(obj->data);
		obj->data = NULL;
	}
	free(obj);
}

void	free_scene_objects(t_scene *scene)
{
	size_t	i;

	if (!scene->objects)
		return ;
	i = 0;
	while (scene->objects[i])
	{
		free_one_object(scene->objects[i]);
		i++;
	}
	free(scene->objects);
	scene->objects = NULL;
}

static void	free_one_light(t_light *light)
{
	if (!light)
		return ;
	free(light);
}

void	free_scene_lights(t_scene *scene)
{
	size_t	i;

	if (!scene->lights)
		return ;
	i = 0;
	while (scene->lights[i])
	{
		free_one_light(scene->lights[i]);
		i++;
	}
	free(scene->lights);
	scene->lights = NULL;
}

void	cleanup_program(t_data *data)
{
	free_scene_objects(&data->scene);
	free_scene_lights(&data->scene);
	if (data->mlx.img.img_ptr)
		mlx_delete_image(data->mlx.mlx_ptr, data->mlx.img.img_ptr);
	if (data->mlx.mlx_ptr)
		mlx_terminate(data->mlx.mlx_ptr);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_basics.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

void	init_scene(t_scene *scene)
{
	scene->width = 0;
	scene->height = 0;
	scene->has_camera = 0;
	scene->has_ambient = 0;
	scene->lights = NULL;
	scene->objects = NULL;
	scene->ambient.ratio = 0.0;
	scene->ambient.color = vec3_init(0, 0, 0);
	scene->camera.fov = 0.0;
	scene->camera.orientation = vec3_init(0, 0, 0);
	scene->camera.position = vec3_init(0, 0, 0);
}

t_material	*create_material(void)
{
	t_material	*material;

	material = malloc(sizeof(t_material));
	if (!material)
		ft_error_exit("Error: Memory allocation for material failed");
	ft_memset(material, 0, sizeof(t_material));
	material->specular.intensity = 0.0f;
	material->specular.shininess = 0;
	material->mirror_ratio = 0.0;
	material->has_checkerboard = 0;
	material->check_color1 = (t_vec3){0, 0, 0};
	material->check_color2 = (t_vec3){0, 0, 0};
	material->check_scale = 1.0;
	material->has_texture = false;
	material->has_normal_map = false;
	material->color_img = NULL;
	material->texture_img = NULL;
	return (material);
}

t_object	*create_object(t_object_type type, void *data, t_vec3 color)
{
	t_object	*obj;

	obj = (t_object *)malloc(sizeof(t_object));
	if (!obj)
		ft_error_exit("Error: Memory allocation for object failed");
	ft_memset(obj, 0, sizeof(t_object));
	obj->type = type;
	obj->data = data;
	obj->color = color;
	obj->material = create_material();
	return (obj);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_color.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

int	color_to_int(t_color color)
{
	int	r;
	int	g;
	int	b;
	int	a;

	r = (int)(color.x * 255.00);
	g = (int)(color.y * 255.00);
	b = (int)(color.z * 255.00);
	a = 255;
	if (r < 0)
		r = 0;
	if (r > 255)
		r = 255;
	if (g < 0)
		g = 0;
	if (g > 255)
		g = 255;
	if (b < 0)
		b = 0;
	if (b > 255)
		b = 255;
	return ((r << 24) | (g << 16) | (b << 8) | a);
}

t_color	int_to_color(int color)
{
	t_color	result;

	result.x = ((color >> 24) & 0xFF) / 255.0;
	result.y = ((color >> 16) & 0xFF) / 255.0;
	result.z = ((color >> 8) & 0xFF) / 255.0;
	return (result);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_elements.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

// Inicializa un rayo con un origen y una dirección.
// Asegura que la dirección esté normalizada.
t_ray	ray_init(t_vec3 origin, t_vec3 direction)
{
	t_ray	r;

	r.origin = origin;
	r.direction = vec3_normalize(direction);
	return (r);
}

// Inicializa una cámara.
t_camera	camera_init(t_vec3 position, t_vec3 orientation, double fov)
{
	t_camera	c;

	c.position = position;
	c.orientation = vec3_normalize(orientation);
	c.fov = fov;
	return (c);
}

// Inicializa la luz ambiental.
t_ambient_light	ambient_light_init(double ratio, t_vec3 color)
{
	t_ambient_light	al;

	al.ratio = ratio;
	al.color = color;
	return (al);
}

// Inicializa una luz puntual.
t_light	light_init(t_vec3 position, double brightness, t_vec3 color)
{
	t_light	l;

	l.position = position;
	l.brightness = brightness;
	l.color = color;
	return (l);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_figures.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

// Inicializa una esfera.
t_sphere	sphere_init(t_vec3 center, double radius)
{
	t_sphere	s;

	s.center = center;
	s.radius = radius;
	return (s);
}

// Inicializa un plano.
// Asegura que la normal esté normalizada.
t_plane	plane_init(t_vec3 position, t_vec3 normal)
{
	t_plane	p;

	p.position = position;
	p.normal = vec3_normalize(normal);
	return (p);
}

// Inicializa un cilindro.
// Asegura que el eje esté normalizado.
t_cylinder	cylinder_init(t_vec3 position, t_vec3 axis, double radius,
		double height)
{
	t_cylinder	cy;

	cy.position = position;
	cy.axis = vec3_normalize(axis);
	cy.radius = radius;
	cy.height = height;
	return (cy);
}

// Inicializa un cono.
// Asegura que el eje esté normalizado.
t_cone	cone_init(t_vec3 position, t_vec3 axis, double radius, double height)
{
	t_cone	cn;

	cn.position = position;
	cn.axis = vec3_normalize(axis);
	cn.radius = radius;
	cn.height = height;
	return (cn);
}

t_hyperboloid	hyperboloid_init(t_vec3 position, t_vec3 axis)
{
	t_hyperboloid	hp;

	hp.position = position;
	hp.axis = vec3_normalize(axis);
	hp.radius_a = 0.0;
	hp.radius_b = 0.0;
	hp.height = 0.0;
	return (hp);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_atof.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/19 15:39:15 by rmarrero          #+#    #+#             */
/*   Updated: 2025/02/19 15:47:34 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

static double	ft_atoi_part(const char **str, int *sign)
{
	double	result;

	result = 0.0;
	while (**str == ' ' || (**str >= 9 && **str <= 13))
		(*str)++;
	if (**str == '-')
	{
		*sign = -1;
		(*str)++;
	}
	else if (**str == '+')
		(*str)++;
	while (**str >= '0' && **str <= '9')
		result = result * 10.0 + (*((*str)++) - '0');
	return (result);
}

double	ft_atof(const char *str)
{
	double	result;
	double	fraction;
	int		sign;

	sign = 1;
	result = ft_atoi_part(&str, &sign);
	fraction = 1.0;
	if (*str == '.')
	{
		str++;
		while (*str >= '0' && *str <= '9')
		{
			fraction *= 0.1;
			result += (*str++ - '0') * fraction;
		}
	}
	return (result * sign);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_atoi.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/11 18:38:41 by rmarrero          #+#    #+#             */
/*   Updated: 2025/01/24 16:28:33 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

// --- ft_atoi version for converting strings to integers --- //
int	ft_atoi(const char *nptr)
{
	int		result;
	size_t	i;
	int		sign;

	sign = 1;
	i = 0;
	result = 0;
	while (nptr[i] == 32 || (nptr[i] >= 9 && nptr[i] <= 13))
		i++;
	if (nptr[i] == '-')
	{
		sign = -1;
		i++;
	}
	else if (nptr[i] == '+')
		i++;
	while (ft_isdigit(nptr[i]))
	{
		result = result * 10 + (nptr[i] - '0');
		i++;
	}
	return (result * sign);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_atoi_long.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/24 16:08:38 by rmarrero          #+#    #+#             */
/*   Updated: 2025/01/24 16:09:52 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

// --- atoi version for long numbers --- //
long	ft_atol(const char *nptr)
{
	long	result;
	size_t	i;
	int		sign;

	sign = 1;
	i = 0;
	result = 0;
	while (nptr[i] == 32 || (nptr[i] >= 9 && nptr[i] <= 13))
		i++;
	if (nptr[i] == '-')
	{
		sign = -1;
		i++;
	}
	else if (nptr[i] == '+')
		i++;
	while (nptr[i] >= '0' && nptr[i] <= '9')
	{
		result = result * 10 + (nptr[i] - '0');
		i++;
	}
	return (result * sign);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_bzero.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/11 18:38:10 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/28 12:16:30 by root             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

void	ft_bzero(void *s, size_t n)
{
	size_t			i;
	unsigned char	*str;

	str = (unsigned char *)s;
	i = 0;
	while (i < n)
	{
		str[i] = 0;
		i++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_calloc.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/18 06:17:42 by rmarrero          #+#    #+#             */
/*   Updated: 2024/11/23 13:30:55 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

void	*ft_calloc(size_t nmemb, size_t size)
{
	void	*pointer;

	if (nmemb && size > SIZE_MAX / nmemb)
		return (NULL);
	pointer = malloc(nmemb * size);
	if (!pointer)
		return (NULL);
	ft_bzero(pointer, nmemb * size);
	return (pointer);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_fabs.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/19 15:47:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/02/19 15:48:16 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

//fabs double
double	ft_fabs_double(double x)
{
	if (x < 0)
		return (-x);
	return (x);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_flags.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/22 14:06:23 by rmarrero          #+#    #+#             */
/*   Updated: 2025/01/24 16:33:01 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

/* %char hunter */
void	is_flag(char c, va_list args, int *length, int *flag)
{
	if (c == 'c')
		ft_putchar((char)va_arg(args, int), length, flag);
	else if (c == 's')
		ft_putstr(va_arg(args, char *), length, flag);
	else if (c == 'p')
		ft_pointer(va_arg(args, uintptr_t), length, flag);
	else if (c == 'u')
		ft_unsigned_putnbr(va_arg(args, unsigned int), length, flag);
	else if (c == 'i' || c == 'd')
		ft_putnbr(va_arg(args, int), length, flag);
	else if (c == 'x')
		ft_hex(va_arg(args, unsigned int), length, 'x', flag);
	else if (c == 'X')
		ft_hex(va_arg(args, unsigned int), length, 'X', flag);
	else if (c == '%')
		ft_putchar('%', length, flag);
}

int	ft_validation(char c)
{
	if (c == 'c' || c == 'i' || c == 's' || c == 'p'\
		|| c == 'u' || c == 'd' || c == 'x' || c == 'X' || c == '%')
		return (1);
	return (-1);
}

/* %u Print an unsigned decimal number (base 10). */
void	ft_unsigned_putnbr(unsigned int unsgined_nbr, int *length, int *flag)
{
	if (unsgined_nbr > 9)
		ft_unsigned_putnbr(unsgined_nbr / 10, length, flag);
	ft_putchar(unsgined_nbr % 10 + '0', length, flag);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_getenv.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/05 13:13:21 by rmarrero          #+#    #+#             */
/*   Updated: 2025/03/05 13:13:25 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

// -- gets environment variable value -- //
char	*ft_getenv(char *name, char **env)
{
	int		i;
	int		j;
	char	*sub;

	i = 0;
	while (env[i])
	{
		j = 0;
		while (env[i][j] && env[i][j] != '=')
			j++;
		sub = ft_substr(env[i], 0, j);
		if (ft_strcmp(sub, name) == 0)
		{
			free(sub);
			return (env[i] + j + 1);
		}
		free(sub);
		i++;
	}
	return (NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isalnum.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/11 18:56:00 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/28 18:16:42 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

int	ft_isalnum(int c)
{
	return (ft_isdigit(c) || ft_isalpha(c));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isalpha.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/11 18:52:42 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/28 16:27:37 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

int	ft_isalpha(int c)
{
	return ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isascii.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/11 18:39:01 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/28 16:28:05 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

int	ft_isascii(int c)
{
	return (c >= 0 && c <= 127);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isdigit.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/12 17:20:00 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/28 16:28:26 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

int	ft_isdigit(int c)
{
	return (c >= '0' && c <= '9');
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isprint.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/12 18:00:10 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/26 12:44:19 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

int	ft_isprint(int c)
{
	return (c >= 32 && c <= 126);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_itoa.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/12 17:43:29 by rmarrero          #+#    #+#             */
/*   Updated: 2024/11/23 13:27:02 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

static int	ft_intlen(int n)
{
	int	len;

	len = 0;
	if (n <= 0)
		len = 1;
	while (n != 0)
	{
		n /= 10;
		len++;
	}
	return (len);
}

void	ft_itoa_recursive(int n, char *str, int *i)
{
	if (n == -2147483648)
	{
		str[(*i)++] = '-';
		str[(*i)++] = '2';
		ft_itoa_recursive(147483648, str, i);
		return ;
	}
	if (n < 0)
	{
		str[(*i)++] = '-';
		n = -n;
	}
	if (n >= 10)
		ft_itoa_recursive(n / 10, str, i);
	str[(*i)++] = (n % 10) + '0';
}

char	*ft_itoa(int n)
{
	char	*str;
	int		i;

	str = (char *)malloc((ft_intlen(n) + 1) * sizeof(char));
	if (!str)
		return (NULL);
	i = 0;
	ft_itoa_recursive(n, str, &i);
	str[i] = '\0';
	return (str);
}
/*
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//itoa de chatgpt
char *itoa(int n)
{
    char *buffer;

    buffer = (char *)malloc(12 * sizeof(char));
    if (!buffer)
        return NULL;

    int index = 0;
    int isNegative = 0;

    // Manejo del caso más negativo
    if (n == -2147483648)
    {
        strcpy(buffer, "-2147483648");
        return buffer;
    }

    // Manejo de números negativos
    if (n < 0)
    {
        isNegative = 1;
        n = -n;
    }

    // Conversión a cadena
    do {
        buffer[index++] = (n % 10) + '0';
        n /= 10;
    } while (n > 0);

    if (isNegative)
        buffer[index++] = '-';

    // Invertir la cadena
    buffer[index] = '\0';
    for (int i = 0; i < index / 2; i++)
    {
        char temp = buffer[i];
        buffer[i] = buffer[index - i - 1];
        buffer[index - i - 1] = temp;
    }

    return buffer;
}

// teste con el itoa de chargpt y el ft_version
void test_itoa(int n)
{
    char *original;
    char *copy;

    original = itoa(n);
    copy = ft_itoa(n);

    printf("Número: %d\n", n);
    printf("itoa chatgpt: %s\n", original);
    printf("ft_itoa: %s\n", copy);
    if (strcmp(original, copy) == 0)
        printf("Test PASADO!\n");
    else
        printf("Test FALLIDO!\n");

    printf("\n");
    free(copy);
}

int main(void)
{
    test_itoa(0);
    test_itoa(1);
    test_itoa(123);
    test_itoa(-123);
    test_itoa(2147483647);
    test_itoa(-2147483648);
    test_itoa(10);
    test_itoa(-10);
    test_itoa(99);
    test_itoa(-99);
    test_itoa(1000);
    test_itoa(-1000);
    test_itoa(10000);
    test_itoa(-10000);
    test_itoa(123456);
    test_itoa(-123456);
    test_itoa(654321);
    test_itoa(-654321);
    test_itoa(123456789);
    test_itoa(-123456789);
    test_itoa(99999);
    test_itoa(-99999);
    test_itoa(500);
    test_itoa(-500);
    test_itoa(7500);
    test_itoa(-7500);
    test_itoa(15000);
    test_itoa(-15000);
    test_itoa(20000);
    test_itoa(-20000);
    test_itoa(30000);
    test_itoa(-30000);
    test_itoa(40000);
    test_itoa(-40000);
    test_itoa(50000);
    test_itoa(-50000);
    test_itoa(60000);
    test_itoa(-60000);
    test_itoa(70000);
    test_itoa(-70000);
    test_itoa(80000);
    test_itoa(-80000);
    test_itoa(90000);
    test_itoa(-90000);
    test_itoa(1234);
    test_itoa(-1234);
    test_itoa(5678);
    test_itoa(-5678);
    test_itoa(13579);
    test_itoa(-13579);
    test_itoa(24680);
    test_itoa(-24680);
    test_itoa(999);
    test_itoa(-999);
    test_itoa(8888);
    test_itoa(-8888);
    test_itoa(77777);
    test_itoa(-77777);
    test_itoa(222);
    test_itoa(-222);
    test_itoa(444);
    test_itoa(-444);
    test_itoa(11111);
    test_itoa(-11111);
    test_itoa(33333);
    test_itoa(-33333);
    test_itoa(55555);
    test_itoa(-55555);
    test_itoa(66666);
    test_itoa(-66666);
    test_itoa(7777);
    test_itoa(-7777);
    test_itoa(1234567);
    test_itoa(-1234567);
    test_itoa(7654321);
    test_itoa(-7654321);
    test_itoa(100000);
    test_itoa(-100000);
    test_itoa(150000);
    test_itoa(-150000);
    test_itoa(200000);
    test_itoa(-200000);
    test_itoa(250000);
    test_itoa(-250000);
    test_itoa(300000);
    test_itoa(-300000);
    test_itoa(350000);
    test_itoa(-350000);
    test_itoa(400000);
    test_itoa(-400000);
    test_itoa(450000);
    test_itoa(-450000);
    test_itoa(500000);
    test_itoa(-500000);
    test_itoa(600000);
    test_itoa(-600000);
    test_itoa(700000);
    test_itoa(-700000);
    test_itoa(800000);
    test_itoa(-800000);
    test_itoa(900000);
    test_itoa(-900000);
    test_itoa(1200000);
    test_itoa(-1200000);
    test_itoa(1500000);
    test_itoa(-1500000);
    test_itoa(1800000);
    test_itoa(-1800000);
    test_itoa(2000000);
    test_itoa(-2000000);
    test_itoa(2200000);
    test_itoa(-2200000);
    test_itoa(2500000);
    test_itoa(-2500000);
    test_itoa(2800000);
    test_itoa(-2800000);
    test_itoa(3000000);
    test_itoa(-3000000);
    test_itoa(3200000);
    test_itoa(-3200000);
    test_itoa(3500000);
    test_itoa(-3500000);
    test_itoa(3700000);
    test_itoa(-3700000);
    test_itoa(3900000);
    test_itoa(-3900000);
    test_itoa(4100000);
    test_itoa(-4100000);
    test_itoa(4300000);
    test_itoa(-4300000);
    test_itoa(4500000);
    test_itoa(-4500000);
    test_itoa(4700000);
    test_itoa(-4700000);
    test_itoa(4900000);
    test_itoa(-4900000);
    test_itoa(5100000);
    test_itoa(-5100000);
    test_itoa(5300000);
    test_itoa(-5300000);
    test_itoa(5500000);
    test_itoa(-5500000);
    test_itoa(5700000);
    test_itoa(-5700000);
    test_itoa(5900000);
    test_itoa(-5900000);
    test_itoa(6100000);
    test_itoa(-6100000);
    test_itoa(6300000);
    test_itoa(-6300000);
    test_itoa(6500000);
    test_itoa(-6500000);
    test_itoa(6700000);
    test_itoa(-6700000);
    test_itoa(6900000);
    test_itoa(-6900000);
    test_itoa(7000000);
    test_itoa(-7000000);
    test_itoa(7200000);
    test_itoa(-7200000);
    test_itoa(7400000);
    test_itoa(-7400000);
    test_itoa(7600000);
    test_itoa(-7600000);
    test_itoa(7800000);
    test_itoa(-7800000);
    test_itoa(8000000);
    test_itoa(-8000000);
    test_itoa(8200000);
    test_itoa(-8200000);
    test_itoa(8400000);
    test_itoa(-8400000);
    test_itoa(8600000);
    test_itoa(-8600000);
    test_itoa(8800000);
    test_itoa(-8800000);
    test_itoa(9000000);
    test_itoa(-9000000);
    test_itoa(9200000);
    test_itoa(-9200000);
    test_itoa(9400000);
    test_itoa(-9400000);
    test_itoa(9600000);
    test_itoa(-9600000);
    test_itoa(9800000);
    test_itoa(-9800000);
    test_itoa(10000000);
    test_itoa(-10000000);
    test_itoa(11000000);
    test_itoa(-11000000);
    test_itoa(12000000);
    test_itoa(-12000000);
    test_itoa(13000000);
    test_itoa(-13000000);
    test_itoa(14000000);
    test_itoa(-14000000);
    test_itoa(15000000);
    test_itoa(-15000000);
    test_itoa(16000000);
    test_itoa(-16000000);
    test_itoa(17000000);
    test_itoa(-17000000);
    test_itoa(18000000);
    test_itoa(-18000000);
    test_itoa(19000000);
    test_itoa(-19000000);
    test_itoa(20000000);
    test_itoa(-20000000);
    test_itoa(21000000);
    test_itoa(-21000000);
    test_itoa(22000000);
    test_itoa(-22000000);

    return 0;
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstadd_back_bonus.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/12 17:43:29 by rmarrero          #+#    #+#             */
/*   Updated: 2024/11/10 23:03:50 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

void	ft_lstadd_back(t_list **lst, t_list *new)
{
	t_list	*last_node;

	if (!lst || !new)
		return ;
	if (!*lst)
		*lst = new;
	else
	{
		last_node = ft_lstlast(*lst);
		last_node->next = new;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstadd_front_bonus.c                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <rmarrero@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/01 22:37:36 by rmarrero          #+#    #+#             */
/*   Updated: 2024/10/01 22:47:57 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

void	ft_lstadd_front(t_list **lst, t_list *new)
{
	if (!lst || !new)
		return ;
	new->next = *lst;
	*lst = new;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstclear_bonus.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/12 17:43:29 by rmarrero          #+#    #+#             */
/*   Updated: 2024/11/10 23:48:28 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

void	ft_lstclear(t_list **lst, void (*del)(void*))
{
	t_list	*tmp;

	if (!lst || !del)
		return ;
	while (*lst)
	{
		tmp = (*lst)->next;
		ft_lstdelone(*lst, *del);
		*lst = tmp;
	}
	*lst = NULL;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstdelone_bonus.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/12 17:43:29 by rmarrero          #+#    #+#             */
/*   Updated: 2024/11/10 23:47:06 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

void	ft_lstdelone(t_list *lst, void (*del)(void*))
{
	if (lst && del)
	{
		(*del)(lst->content);
		free(lst);
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstiter_bonus.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/12 17:43:29 by rmarrero          #+#    #+#             */
/*   Updated: 2024/11/10 23:46:12 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

void	ft_lstiter(t_list *lst, void (*f)(void *))
{
	if (!lst || !f)
		return ;
	while (lst)
	{
		f(lst->content);
		lst = lst->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstlast_bonus.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/12 17:43:29 by rmarrero          #+#    #+#             */
/*   Updated: 2024/11/10 23:45:15 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

t_list	*ft_lstlast(t_list *lst)
{
	if (!lst)
		return (NULL);
	while (lst->next)
		lst = lst->next;
	return (lst);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstmap_bonus.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/12 17:43:29 by rmarrero          #+#    #+#             */
/*   Updated: 2024/11/10 23:06:33 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

t_list	*ft_lstmap(t_list *lst, void *(*f)(void *), void (*del)(void *))
{
	t_list	*new_lst;
	t_list	*new_obj;

	if (!lst || !f || !del)
		return (NULL);
	new_lst = NULL;
	while (lst)
	{
		new_obj = ft_lstnew(f(lst->content));
		if (!new_obj)
		{
			ft_lstclear(&new_lst, del);
			return (NULL);
		}
		ft_lstadd_back(&new_lst, new_obj);
		lst = lst->next;
	}
	return (new_lst);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstnew_bonus.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <rmarrero@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/02 13:19:59 by rmarrero          #+#    #+#             */
/*   Updated: 2024/10/02 13:20:04 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

t_list	*ft_lstnew(void	*content)
{
	t_list	*element;

	element = (t_list *)malloc(sizeof(t_list));
	if (!element)
		return (NULL);
	element->content = content;
	element->next = NULL;
	return (element);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstsize_bonus.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <rmarrero@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/01 23:06:40 by rmarrero          #+#    #+#             */
/*   Updated: 2024/10/02 13:11:18 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

int	ft_lstsize(t_list *lst)
{
	int		count;
	t_list	*list;

	count = 0;
	list = lst;
	while (list)
	{
		count++;
		list = list->next;
	}
	return (count);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memchr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/18 06:59:23 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/28 16:30:52 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

void	*ft_memchr(const void *s, int c, size_t n)
{
	size_t				i;
	const unsigned char	*local_s;

	i = 0;
	local_s = (const unsigned char *)s;
	while (i < n)
	{
		if (local_s[i] == (unsigned char)c)
			return ((void *)&local_s[i]);
		i++;
	}
	return (NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memcmp.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/18 04:41:55 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/28 16:30:15 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

int	ft_memcmp(const void *s1, const void *s2, size_t n)
{
	size_t				i;
	const unsigned char	*local_s1;
	const unsigned char	*local_s2;

	i = 0;
	local_s1 = (const unsigned char *)s1;
	local_s2 = (const unsigned char *)s2;
	while (i < n)
	{
		if (local_s1[i] != local_s2[i])
			return (local_s1[i] - local_s2[i]);
		i++;
	}
	return (0);
}
/*
int	main(void)
{
	char s1[]= "\0";
	char s2[]= "";
	printf("ft_ : %i\n", ft_memcmp(s1, s2, 6));
	printf("original: %i\n", memcmp(s1, s2, 6));
	return 0;
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memcpy.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/13 06:14:58 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/26 12:51:14 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

void	*ft_memcpy(void *dest, const void *src, size_t n)
{
	unsigned char		*local_dest;
	const unsigned char	*local_src;
	size_t				i;

	i = 0;
	local_dest = (unsigned char *)dest;
	local_src = (const unsigned char *)src;
	while (i < n)
	{
		local_dest[i] = local_src[i];
		i++;
	}
	return (dest);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memmove.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/13 06:48:32 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/27 13:42:57 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

void	*ft_memmove(void *dest, const void *src, size_t n)
{
	unsigned char		*local_dest;
	const unsigned char	*local_src;

	if (!dest || !src)
		return (NULL);
	local_dest = (unsigned char *)dest;
	local_src = (const unsigned char *)src;
	if (local_dest < local_src)
		ft_memcpy(dest, src, n);
	else
	{
		while (n--)
			local_dest[n] = local_src[n];
	}
	return (dest);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memset.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/12 18:22:10 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/17 00:02:32 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

void	*ft_memset(void *s, int c, size_t n)
{
	size_t			i;
	unsigned char	*local_s;

	local_s = (unsigned char *)s;
	i = 0;
	while (i < n)
	{
		local_s[i] = (unsigned char)c;
		i++;
	}
	return (s);
}
/*
int 	main(void)
{
	char str[] = "hola";
	printf("antes: %s\n", str);
	ft_memset(str, 1, 2);
	printf("despues: %s\n", str);
}
*/		
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_printf.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/22 14:06:47 by rmarrero          #+#    #+#             */
/*   Updated: 2025/01/24 16:39:25 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

/* dejare el ft_printf para manejo de errores 
 * etc y llamar a las funciones finales */
int	ft_printf(const char *str, ...)
{
	int		i;
	va_list	args;
	int		length;
	int		flag;

	i = -1;
	length = 0;
	flag = 1;
	va_start(args, str);
	while (str[++i])
	{
		if (str[i] == '%' && str[++i])
		{
			if (ft_validation(str[i]) == 1)
				is_flag(str[i], args, &length, &flag);
			else
				return (-1);
		}
		else
			ft_putchar(str[i], &length, &flag);
		if (flag == -1)
			return (-1);
	}
	return (va_end(args), length);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_printf_utils.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/22 14:07:36 by rmarrero          #+#    #+#             */
/*   Updated: 2025/01/24 16:27:51 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

/* %c Prints a single character. */
void	ft_putchar(char character, int *length, int *flag)
{
	if (write(1, &character, 1) == -1)
	{
		(*flag) = -1;
		return ;
	}
	(*length)++;
}

/* %s Prints a string (as defined by default in C) */
void	ft_putstr(char *args, int *length, int *flag)
{
	size_t	i;

	i = 0;
	if (!args)
	{
		if (write(1, "(null)", 6) == -1)
			(*flag) = -1;
		(*length) += 6;
		return ;
	}
	while (args[i])
	{
		ft_putchar(args[i], length, flag);
		i++;
	}
}

/* 
- %d Prints a decimal number (base 10).
- %i Prints an integer in base 10.
*/
void	ft_putnbr(int nbr, int *length, int *flag)
{
	if (nbr == -2147483648)
	{
		if (write(1, "-2147483648", 11) == -1)
			(*flag) = -1;
		(*length) += 11;
		return ;
	}
	if (nbr < 0)
	{
		ft_putchar('-', length, flag);
		ft_putnbr(nbr * -1, length, flag);
	}
	else
	{
		if (nbr > 9)
			ft_putnbr(nbr / 10, length, flag);
		ft_putchar(nbr % 10 + '0', length, flag);
	}
}

/* %p The void pointer * given as argument is printed in hexadecimal format. */
void	ft_pointer(uintptr_t pointer, int *length, int *flag)
{
	char	str_hex[17];
	int		i;
	char	*hex;

	hex = "0123456789abcdef";
	i = 0;
	if (pointer == 0)
	{
		if (write(1, "(nil)", 5) == -1)
			(*flag) = -1;
		(*length) += 5;
		return ;
	}
	if (write(1, "0x", 2) == -1)
		return ((*flag) = -1, (void)0);
	(*length) += 2;
	while (pointer != 0)
	{
		str_hex[i++] = hex[pointer % 16];
		pointer = pointer / 16;
	}
	while (i--)
		ft_putchar(str_hex[i], length, flag);
}

/* %x Prints a hexadecimal number (base 16) in lower case.
%X Prints a hexadecimal number (base 16) in uppercase. */
void	ft_hex(unsigned int nbr, int *length, char x, int *flag)
{
	char	str_hex[17];
	char	*hex;
	int		i;

	if (x == 'X')
		hex = "0123456789ABCDEF";
	else
		hex = "0123456789abcdef";
	i = 0;
	if (nbr == 0)
	{
		ft_putchar('0', length, flag);
		return ;
	}
	while (nbr != 0)
	{
		str_hex[i] = hex[nbr % 16];
		nbr = nbr / 16;
		i++;
	}
	while (i--)
		ft_putchar(str_hex[i], length, flag);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putchar_fd.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/26 12:52:58 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/26 12:53:14 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

void	ft_putchar_fd(char c, int fd)
{
	write(fd, &c, 1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putendl_fd.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/26 12:41:15 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/29 11:38:13 by root             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

void	ft_putendl_fd(char *s, int fd)
{
	if (s == NULL)
		return ;
	write(fd, s, ft_strlen(s));
	write(fd, "\n", 1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putnbr_fd.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/26 12:51:31 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/26 12:52:26 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

void	ft_putnbr_fd(int n, int fd)
{
	char	digit;

	if (n == -2147483648)
	{
		write(fd, "-2147483648", 11);
		return ;
	}
	if (n < 0)
	{
		write(fd, "-", 1);
		n = -n;
	}
	if (n >= 10)
		ft_putnbr_fd(n / 10, fd);
	digit = (n % 10) + '0';
	write(fd, &digit, 1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putstr_fd.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/26 12:36:14 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/29 16:23:53 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

void	ft_putstr_fd(char *s, int fd)
{
	if (s == NULL)
		return ;
	write(fd, s, ft_strlen(s));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_realloc.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/13 06:14:58 by rmarrero          #+#    #+#             */
/*   Updated: 2025/06/30 15:53:27 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

void	*ft_realloc(void *ptr, size_t new_size)
{
	void	*new_ptr;

	if (new_size == 0)
	{
		free(ptr);
		return (NULL);
	}
	if (!ptr)
		return (malloc(new_size));
	new_ptr = malloc(new_size);
	if (!new_ptr)
		return (NULL);
	ft_memcpy(new_ptr, ptr, new_size);
	free(ptr);
	return (new_ptr);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_split.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/12 17:43:29 by rmarrero          #+#    #+#             */
/*   Updated: 2024/11/10 23:52:13 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

static char	*ft_strncpy(char *dest, const char *src, unsigned int n)
{
	unsigned int	i;

	i = 0;
	while (i < n && src[i] != '\0')
	{
		dest[i] = src[i];
		i++;
	}
	while (i < n)
	{
		dest[i] = '\0';
		i++;
	}
	return (dest);
}

static int	count_words(const char *s, char c)
{
	int	count;

	count = 0;
	while (*s)
	{
		while (*s == c || *s == '\t')
			s++;
		if (*s)
		{
			count++;
			while (*s && *s != c && *s != '\t')
				s++;
		}
	}
	return (count);
}

static char	*ft_word_dup(const char *s, char c)
{
	unsigned int	len;
	char			*word;

	len = 0;
	while (s[len] && s[len] != c && s[len] != '\t')
		len++;
	word = (char *)malloc(sizeof(char) * (len + 1));
	if (!word)
		return (NULL);
	ft_strncpy(word, s, len);
	word[len] = '\0';
	return (word);
}

static void	ft_free_split(char **split)
{
	int	i;

	i = 0;
	while (split[i])
	{
		free(split[i]);
		i++;
	}
	free(split);
}

char	**ft_split(char const *s, char c)
{
	int		words;
	char	**split;
	int		i;

	i = 0;
	words = count_words(s, c);
	split = (char **)malloc(sizeof(char *) * (words + 1));
	if (!split)
		return (NULL);
	while (*s)
	{
		while (*s == c || *s == '\t')
			s++;
		if (*s)
		{
			split[i] = ft_word_dup(s, c);
			if (!split[i++])
				return (ft_free_split(split), NULL);
			while (*s && *s != c && *s != '\t')
				s++;
		}
	}
	return (split[i] = NULL, split);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_sqrt.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/24 16:10:29 by rmarrero          #+#    #+#             */
/*   Updated: 2025/01/24 16:11:13 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

int	ft_sqrt(int nb)
{
	int	low;
	int	high;
	int	mid;

	if (nb < 0)
		return (0);
	if (nb == 0 || nb == 1)
		return (nb);
	low = 0;
	high = nb;
	mid = (low + high) / 2;
	while (low <= high)
	{
		mid = (low + high) / 2;
		if (mid * mid == nb)
			return (mid);
		else if (mid * mid < nb)
			low = mid + 1;
		else
			high = mid - 1;
	}
	if ((low * low - nb) < (nb - high * high))
		return (low);
	return (high);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strchr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/13 12:40:32 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/18 06:39:35 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

char	*ft_strchr(const char *s, int c)
{
	const unsigned char	*local_s;
	size_t				i;

	i = 0;
	local_s = (const unsigned char *)s;
	while (local_s[i])
	{
		if (local_s[i] == (unsigned char)c)
			return ((char *)&s[i]);
		i++;
	}
	if ((unsigned char)c == '\0')
		return ((char *)&s[i]);
	return (NULL);
}
/*
int	main(void)
{
    char str[] = "hola mundo new world";
    char c = 'u';

    printf("%s", ft_strchr(str, c));
    return 0;
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strcmp.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/19 15:39:15 by rmarrero          #+#    #+#             */
/*   Updated: 2025/03/03 12:14:41 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

int	ft_strcmp(const char *s1, const char *s2)
{
	int	i;

	i = 0;
	while (s1[i] && s2[i])
	{
		if (s1[i] != s2[i])
			return (s1[i] - s2[i]);
		i++;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strdup.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/10 15:46:22 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/13 12:59:38 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

char	*ft_strdup(const char *s1)
{
	size_t	i;
	char	*duplicado;

	if (s1 == NULL)
		return (NULL);
	duplicado = (char *)malloc((ft_strlen(s1) + 1) * sizeof(char));
	if (!duplicado)
		return (NULL);
	i = 0;
	while (s1[i])
	{
		duplicado[i] = s1[i];
		i++;
	}
	duplicado[i] = '\0';
	return (duplicado);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_striteri.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/26 12:28:38 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/28 16:35:40 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

void	ft_striteri(char *s, void (*f)(unsigned int, char*))
{
	unsigned int	i;

	if (s == NULL || f == NULL)
		return ;
	i = 0;
	while (s[i])
	{
		(*f)(i, &s[i]);
		i++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strjoin.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/19 12:24:10 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/26 12:20:24 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

char	*ft_strjoin(char const *s1, char const *s2)
{
	char	*dest;
	int		i;
	int		j;

	if (s1 == NULL && s2 == NULL)
		return (NULL);
	if (s1 == NULL)
		return (ft_strdup(s2));
	if (s2 == NULL)
		return (ft_strdup(s1));
	dest = (char *)malloc((ft_strlen(s1) + ft_strlen(s2) + 1) * sizeof(char));
	if (!dest)
		return (NULL);
	i = 0;
	j = 0;
	while (s1[i])
		dest[j++] = s1[i++];
	i = 0;
	while (s2[i])
		dest[j++] = s2[i++];
	dest[j] = '\0';
	return (dest);
}
/*
int	main(void)
{
		char s1[] = "hola ";
		char s2[] = "mundo";
		printf("%s", ft_strjoin(s1, s2));
		return 0;
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlcat.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/11 18:43:29 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/15 20:52:37 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

size_t	ft_strlcat(char *dest, char *src, unsigned int size)
{
	size_t	i;
	size_t	dlen;
	size_t	slen;

	i = 0;
	dlen = ft_strlen(dest);
	slen = ft_strlen(src);
	if (size <= dlen)
		return (slen + size);
	while (src [i] && i < size - dlen - 1)
	{
		dest[dlen + i] = src[i];
		i++;
	}
	dest[dlen + i] = '\0';
	return (dlen + slen);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlcpy.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/12 17:56:18 by rmarrero          #+#    #+#             */
/*   Updated: 2024/11/23 13:01:34 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

size_t	ft_strlcpy(char *dest, const char *src, size_t	size)
{
	size_t	i;
	size_t	length_src;

	i = 0;
	length_src = ft_strlen(src);
	if (size > 0)
	{
		while (src[i] && i < (size - 1))
		{
			dest[i] = src[i];
			i++;
		}
		dest[i] = '\0';
	}
	return (length_src);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlen.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/12 17:36:43 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/13 12:34:31 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

size_t	ft_strlen(const char *str)
{
	int	length;

	length = 0;
	while (str[length])
		length++;
	return (length);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strmapi.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/26 13:34:07 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/27 15:49:34 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strmapi(char const *s, char (*f)(unsigned int, char))
{
	unsigned int	i;
	char			*result;

	if (!s || !f)
		return (NULL);
	result = (char *)malloc((ft_strlen(s) + 1) * sizeof(char));
	if (!result)
		return (NULL);
	i = 0;
	while (s[i])
	{
		result[i] = (*f)(i, s[i]);
		i++;
	}
	result[i] = '\0';
	return (result);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strncmp.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/17 07:32:01 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/29 11:27:27 by root             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

int	ft_strncmp(const char *s1, const char *s2, size_t n)
{
	size_t	i;

	i = 0;
	while (i < n && (s1[i] || s2[i]))
	{
		if (s1[i] != s2[i])
			return ((unsigned char)s1[i] - (unsigned char)s2[i]);
		i++;
	}
	return (0);
}
/*
int main(void)
{
	char	str1[] = "abcav";
	char	str2[] = "abca";
	printf("%i", ft_strncmp(str1, str2, 4));
	return 0;
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strnstr.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/17 23:29:06 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/18 06:40:26 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

char	*ft_strnstr(const char *big, const char *little, size_t len)
{
	size_t	i;
	size_t	j;

	if (!big)
		return (0);
	if (*little == '\0')
		return ((char *)big);
	i = 0;
	while (big[i] && i < len)
	{
		j = 0;
		while (big[i + j] == little[j] && (i + j) < len)
		{
			if (little[j + 1] == '\0')
				return ((char *)&big[i]);
			j++;
		}
		i++;
	}
	return (NULL);
}
/*
int main(void) {
    char big[] = "Hola mundo texto  nuevo";
    char littel[] = "texto";
    printf("%s\n", ft_strnstr(big, littel, 25));
    return 0;
}
*/	
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strrchr.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/12 17:43:29 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/29 11:50:22 by root             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

char	*ft_strrchr(const char *str, char c)
{
	const unsigned char		*local_str;
	size_t					len;

	len = ft_strlen(str);
	local_str = (const unsigned char *)str;
	if ((unsigned char)c == '\0')
		return ((char *)&local_str[len]);
	while (len > 0)
	{
		len--;
		if (local_str[len] == (unsigned char)c)
			return ((char *)&local_str[len]);
	}
	return (NULL);
}
/*
int main()
{
    char str[] = "www.holamundo.com";
    char c = '.';

    printf("%s", ft_strrchr(str,c));

    return 0;
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strtrim.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/26 12:26:57 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/26 13:31:11 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strtrim(char const *s1, char const *set)
{
	size_t	i;
	size_t	j;
	size_t	k;
	char	*str;

	if (!s1 || !set)
		return (NULL);
	i = 0;
	j = ft_strlen(s1);
	while (s1[i] && ft_strchr(set, s1[i]))
		i++;
	while (j > i && ft_strchr(set, s1[j - 1]))
		j--;
	str = (char *)malloc((j - i + 1) * sizeof(char));
	if (!str)
		return (NULL);
	k = 0;
	while (k < (j - i))
	{
		str[k] = s1[i + k];
		k++;
	}
	str[k] = '\0';
	return (str);
}
/*
int main()
{
    char s1[] = "sdhola mdsdunsdto csomso ddestdas";
    char set[] = "sd";
    char *result = ft_strtrim(s1, set);
    printf("%s\n", result);
    free(result);
    return 0;
}
*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_substr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/18 19:06:56 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/26 12:35:50 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"
//#include <stdio.h>
//#include <stdlib.h>

/*
void    ft_bzero(void *s, size_t n);
size_t  ft_strlen(const char *str);
char    *ft_strdup(const char *s1);
void    *ft_calloc(size_t count, size_t size);
*/

char	*ft_substr(char const *s, unsigned int start, size_t len)
{
	size_t	i;
	char	*pointer;

	if (!s)
		return (NULL);
	if (start > ft_strlen(s))
		return (ft_strdup(""));
	if (len > ft_strlen(s + start))
		len = ft_strlen(s + start);
	pointer = ft_calloc(len + 1, sizeof(char));
	if (!pointer)
		return (NULL);
	i = 0;
	while (i < len)
	{
		pointer[i] = s[start + i];
		i++;
	}
	return (pointer);
}
/*
int	main(void)
{
	char s[] = "Hi new world, new testing text for this function.";
	printf("new testing: %s\n", ft_substr(s, 14, 11));
	return (0);
}

void    ft_bzero(void *s, size_t n)
{
        size_t                  i;
        unsigned char   *str;

        str = (unsigned char *)s;
        i = 0;
        while (i < n)
        {
                str[i] = '\0';
                i++;
        }
}

size_t  ft_strlen(const char *str)
{
        int     length;

        length = 0;
        while (str[length])
                length++;
        return (length);
}
char    *ft_strdup(const char *s1)
{
        size_t  i;
        char    *duplicado;

        i = 0;
        duplicado = (char *)malloc((ft_strlen(s1) + 1) * sizeof(char));
        if (!duplicado)
                return (NULL);
        while (s1[i])
        {
                duplicado[i] = s1[i];
                i++;
        }
        duplicado[i] = '\0';
        return (duplicado);
}

void    *ft_calloc(size_t count, size_t size)
{
        size_t                  i;
        unsigned char   *pointer;

        i = 0;
        pointer = malloc(count * size);
        if (!pointer)
                return (NULL);
        ft_bzero(pointer, count * size);
        return (pointer);
}
*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_tolower.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/17 08:25:40 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/18 06:32:03 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

int	ft_tolower(int c)
{
	unsigned char	local_c;

	local_c = (unsigned char)c;
	while (local_c >= 'A' && local_c <= 'Z')
		return (c += 32);
	return (c);
}
/*
int main(void)
{
	char str[] = "HOLA MUNDO";
	int i = 0;

	while (str[i])
	{
		printf("%c", ft_tolower(str[i]));
		i++;
	}
}*/	
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_toupper.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/17 08:12:23 by rmarrero          #+#    #+#             */
/*   Updated: 2024/09/18 06:32:54 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

int	ft_toupper(int c)
{
	if (c >= 'a' && c <= 'z')
		return (c -= 32);
	return (c);
}
/*
int main(void)
{
	char	str[] = "hola";
	int 	i = 0;
	while (str[i])
	{
		printf("%c", ft_toupper(str[i]));
		i++;
	}
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_bonus.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <rmarrero@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/01 21:11:16 by rmarrero          #+#    #+#             */
/*   Updated: 2024/10/28 20:58:15 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

char	*get_next_line(int fd)
{
	static t_list	*list[4096];
	char			*line;

	line = NULL;
	if (BUFFER_SIZE < 0 || fd < 0)
		return (NULL);
	create_and_append(list, fd);
	line = malloc(get_len(list[fd]) + 1);
	if (!(list[fd]) || !(line))
		return (free(line), NULL);
	get_copy(list[fd], line);
	get_clear_remaining_data(&list[fd]);
	return (line);
}

void	get_free_list(t_list **list, t_list *replace, char *buffer)
{
	t_list	*tmp;

	if (NULL == *list)
		return ;
	while (*list)
	{
		tmp = (*list)->next;
		free((*list)->content);
		free(*list);
		*list = tmp;
	}
	*list = NULL;
	if (replace->content[0])
		*list = replace;
	else
	{
		free(buffer);
		free(replace);
	}
}

void	get_clear_remaining_data(t_list **list)
{
	char	*buffer;
	t_list	*last;
	t_list	*replace;
	int		i;
	int		j;

	i = 0;
	j = 0;
	buffer = malloc(BUFFER_SIZE + 1);
	replace = malloc(sizeof(t_list));
	if (!(buffer) || !(replace))
		return ;
	last = ft_lstlast(*list);
	while (last->content[i] && last->content[i] != '\n')
		++i;
	while (last->content[i] && last->content[++i])
		buffer[j++] = last->content[i];
	buffer[j] = '\0';
	replace->content = buffer;
	replace->next = NULL;
	get_free_list(list, replace, buffer);
}
//comand > 
//gcc -o get_next_line main.c get_next_line.c get_next_line_utils.c -I./includes
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line_utils_bonus.c                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <rmarrero@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/27 23:07:54 by rmarrero          #+#    #+#             */
/*   Updated: 2024/10/12 23:10:36 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

int	get_len(t_list *list)
{
	int	i;
	int	len;

	if (!list)
		return (0);
	len = 0;
	while (list)
	{
		i = 0;
		while (list->content[i])
		{
			if (list->content[i] == '\n')
				return (++len);
			++i;
			++len;
		}
		list = list->next;
	}
	return (len);
}

void	get_copy(t_list *list, char *line)
{
	int	i;
	int	j;

	if (!list)
		return ;
	j = 0;
	while (list)
	{
		i = 0;
		while (list->content[i])
		{
			if (list->content[i] == '\n')
			{
				line[j++] = '\n';
				line[j] = '\0';
				return ;
			}
			line[j++] = list->content[i++];
		}
		list = list->next;
	}
	line[j] = '\0';
}

int	find_new_line(t_list *list)
{
	int	i;

	if (!list)
		return (0);
	while (list)
	{
		i = 0;
		while (list->content[i] && i < BUFFER_SIZE)
		{
			if (list->content[i] == '\n')
				return (1);
			i++;
		}
		list = list->next;
	}
	return (0);
}

void	create_and_append(t_list **list, int fd)
{
	t_list	*new_node;
	t_list	*last_node;
	char	*buffer;
	int		bytes_read;

	while (!find_new_line(list[fd]))
	{
		buffer = malloc(BUFFER_SIZE + 1);
		bytes_read = read(fd, buffer, BUFFER_SIZE);
		if (!(buffer) || bytes_read <= 0)
			return (free(buffer), (void)0);
		buffer[bytes_read] = '\0';
		new_node = malloc(sizeof(t_list));
		if (!new_node)
			return ;
		new_node->content = buffer;
		new_node->next = NULL;
		if (!list[fd])
			list[fd] = new_node;
		else
		{
			last_node = ft_lstlast(list[fd]);
			last_node->next = new_node;
		}
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   libft.h                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/09/12 18:01:25 by rmarrero          #+#    #+#             */
/*   Updated: 2025/06/30 15:54:14 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#ifndef LIBFT_H
# define LIBFT_H
# include <fcntl.h>
# include <limits.h>
# include <stdarg.h>
# include <stddef.h>
# include <stdint.h>
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <unistd.h>

# ifndef SIZE_MAX
#  define SIZE_MAX 4294967295
# endif

// --- Mandaroty --- //
// --- void functions --- //
void				*ft_memset(void *s, int c, size_t n);
void				ft_bzero(void *s, size_t n);
void				*ft_memcpy(void *dest, const void *src, size_t n);
void				*ft_memmove(void *dest, const void *src, size_t n);
void				*ft_memchr(const void *s, int c, size_t n);

// --- numbers funtions --- //
// --- int funtions --- //
int					ft_isalpha(int c);
int					ft_isdigit(int c);
int					ft_isalnum(int c);
int					ft_isascii(int c);
int					ft_isprint(int c);
int					ft_toupper(int c);
int					ft_tolower(int c);
int					ft_strncmp(const char *s1, const char *s2, size_t n);
int					ft_memcmp(const void *s1, const void *s2, size_t n);
int					ft_atoi(const char *nptr);

// --- size_t functions --- //
size_t				ft_strlen(const char *str);
size_t				ft_strlcpy(char *dest, const char *src, size_t size);
size_t				ft_strlcat(char *dest, char *src, unsigned int size);

// --- char functions --- //
char				*ft_strchr(const char *s, int c);
char				*ft_strrchr(const char *str, char c);
char				*ft_strnstr(const char *big, const char *little,
						size_t len);

// --- parte 2 --- //
char				*ft_strtrim(char const *s1, char const *set);
char				*ft_strjoin(char const *s1, char const *s2);
char				*ft_substr(char const *s, unsigned int start, size_t len);
char				**ft_split(char const *s, char c);
char				*ft_itoa(int n);
char				*ft_strmapi(char const *s, char (*f)(unsigned int, char));
void				ft_striteri(char *s, void (*f)(unsigned int, char *));
void				ft_putchar_fd(char c, int fd);
void				ft_putstr_fd(char *s, int fd);
void				ft_putendl_fd(char *s, int fd);
void				ft_putnbr_fd(int n, int fd);
void				*ft_calloc(size_t count, size_t size);
char				*ft_strdup(const char *s);

// --- libft bonus --- //

// --- bonus strct --- //
typedef struct s_list
{
	char			*content;
	struct s_list	*next;
}					t_list;
// --- Bonus Functions --- //

// --- t_list funtions ---
t_list				*ft_lstlast(t_list *lst);
t_list				*ft_lstnew(void *content);
t_list				*ft_lstmap(t_list *lst, void *(*f)(void *),
						void (*del)(void *));

// --- int funtions --- //
int					ft_lstsize(t_list *lst);

// --- void funtions ---
void				ft_lstadd_front(t_list **lst, t_list *new);
void				ft_lstadd_back(t_list **lst, t_list *new);
void				ft_lstdelone(t_list *lst, void (*del)(void *));
void				ft_lstclear(t_list **lst, void (*del)(void *));
void				ft_lstiter(t_list *lst, void (*f)(void *));

// --- get_next_line --- //

// --- define of flags -D BUFFER_SIZE X  --- //
# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 42
# endif

void				get_copy(t_list *list, char *line);
void				get_free_list(t_list **list, t_list *replace, char *buffer);
int					get_len(t_list *list);
t_list				*get_last_node(t_list *list);
int					find_new_line(t_list *list);
void				get_clear_remaining_data(t_list **list);
void				create_and_append(t_list **list, int fd);
char				*get_next_line(int fd);

// --- ft_printf --- //

// --- valitions --- //
int					ft_validation(char c);
int					ft_printf(const char *str, ...);
void				is_flag(char c, va_list args, int *length, int *flag);
void				ft_unsigned_putnbr(unsigned int unsigned_nbr, int *length,
						int *flag);
void				ft_putchar(const char c, int *length, int *flag);
void				ft_putstr(char *args, int *length, int *flag);
void				ft_putnbr(int nbr, int *length, int *flag);
void				ft_pointer(size_t pointer, int *length, int *flag);
void				ft_hex(unsigned int nbr, int *length, char x, int *flag);

// --- push_swap --- //

// --- long funtions --- //
long				ft_atol(const char *nptr);

// --- int funtions --- //
int					ft_sqrt(int nb);
// --- double --- //
double				ft_fabs_double(double x);
double				ft_atof(const char *str);

// --- pipex --- //
int					ft_strcmp(const char *s1, const char *s2);

// -- gets environment variable value -- //
char				*ft_getenv(char *name, char **env);
void				*ft_realloc(void *ptr, size_t new_size);

#endif
# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    Makefile                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: rmarrero <marvin@42.fr>                    +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2024/09/16 12:58:52 by rmarrero          #+#    #+#              #
#    Updated: 2025/06/30 15:53:55 by rmarrero         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

# --- mandatory functions --- #
SRC = ft_isascii.c ft_memcpy.c ft_putstr_fd.c ft_strlcat.c ft_strrchr.c ft_atoi.c ft_isdigit.c\
ft_memmove.c ft_strlcpy.c ft_strtrim.c ft_bzero.c ft_isprint.c ft_memset.c ft_strchr.c \
ft_strlen.c ft_calloc.c ft_putchar_fd.c ft_strdup.c ft_strmapi.c ft_tolower.c ft_substr.c\
ft_isalnum.c ft_memchr.c ft_putendl_fd.c ft_striteri.c ft_strncmp.c ft_toupper.c ft_isalpha.c \
ft_memcmp.c ft_putnbr_fd.c   ft_strjoin.c ft_strnstr.c ft_split.c ft_itoa.c
OBJS = $(SRC:.c=.o)

# --- bonus functions --- #
BSRC = ft_lstnew_bonus.c ft_lstadd_front_bonus.c ft_lstsize_bonus.c ft_lstlast_bonus.c ft_lstadd_back_bonus.c \
ft_lstdelone_bonus.c ft_lstclear_bonus.c ft_lstiter_bonus.c ft_lstmap_bonus.c get_next_line_utils.c\
get_next_line.c ft_printf.c ft_flags.c ft_printf_utils.c
BOBJS = $(BSRC:.c=.o)

# --- ft_printf functions --- #
# --- get_next_line functions --- #
# --- additional functions --- #
ADDSRC = ft_sqrt.c ft_atol.c ft_fabs.c ft_atof.c ft_strcmp.c ft_getenv.c ft_realloc.c
ADDOBJS = $(ADDSRC:.c=.o)

NAME = libft.a
HEADER = libft.h
CC = cc
CFLAGS = -Wall -Werror -Wextra -fPIE
RM = rm -f
AR = ar rsc

#color
RED     = \033[31m
GREEN   = \033[32m
YELLOW  = \033[33m
BLUE    = \033[34m
RESET   = \033[0m

#ifdef BONUS
OBJECTS = $(OBJS) $(BOBJS) $(ADDOBJS)

all: $(NAME)

$(NAME): $(OBJECTS)
	@echo "$(GREEN)Compilando...$(RESET)"
	$(AR) $(NAME) $?
	@echo "$(BLUE)"
	@echo "$(YELLOW)           ($(RESET)__$(YELLOW))\           $(RESET)"
	@echo "$(YELLOW)           ($(RESET)oo$(YELLOW))\\________  $(RESET)"
	@echo "$(RESET)           /|| \\        \\ $(RESET)"
	@echo "$(RESET)              ||------w | $(RESET)"
	@echo "$(RESET)              ||       || $(RESET)"
	@echo "$(YELLOW)THE COW MAKES MUUUUUUUUUU!$(RESET)"
	@echo "$(RESET)"

%.o: %.c $(HEADER) Makefile
	$(CC) $(CFLAGS) -c $< -o $@

clean:
	$(RM) $(OBJS) $(BOBJS) $(ADDOBJS)

fclean: clean
	$(RM) -f $(NAME)
	
re: fclean all

.PHONY : all clean fclean re
# Libft

**Libft** es una biblioteca personalizada escrita en C que implementa una colección de funciones estándar de la biblioteca C, junto con funciones adicionales como `get_next_line` y `ft_printf`. El objetivo de este proyecto es crear una base sólida de funciones reutilizables para futuros proyectos.

---

## Funciones incluidas

### Funciones de la biblioteca estándar (`my_libft`)
- ft_isascii
- ft_memcpy
- ft_putstr_fd
- ft_strlcat
- ft_strrchr
- ft_atoi
- ft_isdigit
- ft_memmove
- ft_strlcpy
- ft_strtrim
- ft_bzero
- ft_isprint
- ft_memset
- ft_strchr
- ft_strlen
- ft_calloc
- ft_putchar_fd
- ft_strdup
- ft_strmapi
- ft_tolower
- ft_substr
- ft_isalnum
- ft_memchr
- ft_putendl_fd
- ft_striteri
- ft_strncmp
- ft_toupper
- ft_isalpha
- ft_memcmp
- ft_putnbr_fd
- ft_strjoin
- ft_strnstr
- ft_split
- ft_itoa

### Funciones adicionales
- ft_lstnew_bonus
- ft_lstadd_front_bonus
- ft_lstsize_bonus
- ft_lstlast_bonus
- ft_lstadd_back_bonus
- ft_lstdelone_bonus
- ft_lstclear_bonus
- ft_lstiter_bonus
- ft_lstmap_bonus

### Funciones específicas
- get_next_line
- [ft_printf](https://github.com/rogerdevworld/ft_printf)

---
## Compilación con `make`

Este proyecto incluye un único **Makefile** que compila automáticamente todos los archivos de la biblioteca. Simplemente ejecuta el comando:

```bash
make
```
## Compilación con `make bonus`

Las funciones bonus en el **Makefile** fue comentada solo con hacer make puede tener todas las funciones asi en el proyecto puedo hacer make u complar todo, aun asi es posible activar para usar el comando:

```bash
make bonus
```
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../include/minirt.h"

int	init_data(t_data *data)
{
	init_scene(&data->scene);
	data->scene.lights = NULL;
	data->scene.num_lights = 0;
	data->scene.width = 1920;
	data->scene.height = 1080;
	data->num_threads = get_num_processors();
	data->rendered_rows = 0;
	data->auto_rotate_active = false;
	data->rotation_angle = 0.0;
	data->rotation_center = vec3_init(0, 0, 0);
	if (pthread_mutex_init(&data->progress_mutex, NULL) != 0)
		return (printf("MiniRT: Error: Bad Init Mutex\n"), 1);
	return (0);
}

// moving
int	main(int argc, char **argv)
{
	t_data	data;

	if (argc != 2)
		return (printf("Usage: ./minirt <scene.rt>\n"), 1);
	if (init_data(&data) != 0)
		return (1);
	parse_rt_file(&data.scene, argv[1]);
	if (mlx_setup(&data) != 0)
		return (cleanup_program(&data), 1);
	render_threaded(&data);
	mlx_key_hook(data.mlx.mlx_ptr, key_hook, &data);
	mlx_loop(data.mlx.mlx_ptr);
	cleanup_program(&data);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_error.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minirt.h"

void	ft_error_exit(const char *msg)
{
	ft_putendl_fd((char *)msg, 2);
	exit(EXIT_FAILURE);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minirt.h"

int	open_filename(const char *filename)
{
	int	fd;

	fd = open(filename, O_RDONLY);
	if (fd < 0)
	{
		perror("Error: cannot open the file");
		exit(1);
	}
	return (fd);
}

void	validate_file(int fd, const char *file_name)
{
	char	buffer[1];
	ssize_t	b_read;

	b_read = read(fd, buffer, 1);
	if (b_read < 0)
	{
		if (errno == EISDIR)
			printf("Error: %s is not a file, is a directory\n", file_name);
		else
			perror("Error: cannot read the file");
		close(fd);
		exit(1);
	}
	else if (b_read == 0)
	{
		printf("Error: the file %s is empty\n", file_name);
		close(fd);
		exit(1);
	}
}

static void	parse_line(t_scene *scene, char *line)
{
	char	**tokens;

	tokens = ft_split(line, ' ');
	if (!tokens)
		ft_error_exit("MiniRT: Error: ft_split failed");
	if (ft_strcmp(tokens[0], "A") == 0)
		parse_ambient(scene, tokens);
	else if (ft_strcmp(tokens[0], "C") == 0)
		parse_camera(scene, tokens);
	else if (ft_strcmp(tokens[0], "L") == 0)
		parse_light(scene, tokens);
	else if (ft_strcmp(tokens[0], "sp") == 0)
		parse_sphere(scene, tokens);
	else if (ft_strcmp(tokens[0], "pl") == 0)
		parse_plane(scene, tokens);
	else if (ft_strcmp(tokens[0], "cy") == 0)
		parse_cylinder(scene, tokens);
	else if (ft_strcmp(tokens[0], "cn") == 0)
		parse_cone(scene, tokens);
	else if (ft_strcmp(tokens[0], "pb") == 0)
		parse_paraboloid(scene, tokens);
	else if (ft_strcmp(tokens[0], "hp") == 0)
		parse_hyperboloid(scene, tokens);
	ft_free_str_array(tokens);
}

static int	open_and_validate_file(const char *file_path)
{
	int	fd;

	if (!valid_extension_rt(file_path))
		ft_error_exit("MiniRT: Error: the file must be of type '*.rt'");
	fd = open_filename(file_path);
	validate_file(fd, file_path);
	close(fd);
	fd = open_filename(file_path);
	return (fd);
}

void	parse_rt_file(t_scene *scene, const char *file_path)
{
	int		fd;
	char	*line;

	fd = open_and_validate_file(file_path);
	line = get_next_line(fd);
	while (line != NULL)
	{
		parse_line(scene, line);
		free(line);
		line = get_next_line(fd);
	}
	close(fd);
	if (!scene->has_camera || !scene->has_ambient)
		ft_error_exit("MiniRT: Error: A camera and \
            ambient light are required.");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_elements_2.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minirt.h"

// Nuevo parser para Hiperboloide (hp)
void	parse_hyperboloid(t_scene *scene, char **tokens)
{
	t_hyperboloid	*hb;
	t_object		*obj;

	if (ft_strarr_len(tokens) < 7)
		ft_error_exit("Error: Hyperboloid format invalid");
	hb = malloc(sizeof(t_hyperboloid));
	if (!hb)
		ft_error_exit("Error: Memory allocation failed");
	hb->position = parse_vec3(tokens[1]);
	hb->axis = parse_vec3_normalized(tokens[2]);
	hb->radius_a = parse_positive_double(tokens[3]);
	hb->radius_b = parse_positive_double(tokens[4]);
	hb->height = parse_positive_double(tokens[5]);
	obj = create_object(HYPERBOLOID, hb, parse_vec3_color(tokens[6]));
	apply_object_modifiers(obj, tokens, 7);
	add_object_to_scene(scene, obj);
}

// Parser de Cámara (C)
void	parse_camera(t_scene *scene, char **tokens)
{
	if (scene->has_camera)
		ft_error_exit("Error: Multiple cameras not allowed");
	if (ft_strarr_len(tokens) != 4)
		ft_error_exit("Error: Camera format invalid");
	scene->camera.position = parse_vec3(tokens[1]);
	scene->camera.orientation = parse_vec3_normalized(tokens[2]);
	scene->camera.fov = parse_fov(tokens[3]);
	scene->has_camera = 1;
}

// Parser de Luz (L)
void	parse_light_movement(t_light *light, char **tokens, int num_tokens)
{
	if (ft_strcmp(tokens[4], "") == 0)
		return ;
	if (ft_strcmp(tokens[4], "moving") == 0)
	{
		if (num_tokens == 6)
		{
			if (ft_strcmp(tokens[5], "circle") == 0)
				light->movement_type = MOVEMENT_CIRCLE;
			else if (ft_strcmp(tokens[5], "triangle") == 0)
				light->movement_type = MOVEMENT_TRIANGLE;
			else if (ft_strcmp(tokens[5], "line") == 0)
				light->movement_type = MOVEMENT_LINE;
			else
				ft_error_exit("Error: Unrecognized light movement type.");
		}
		else
			ft_error_exit("Error: 'moving' light requires a movement type.");
	}
	else
		ft_error_exit("Error: Unrecognized light option.");
}

void	parse_light(t_scene *scene, char **tokens)
{
	t_light	*light;
	int		num_tokens;

	num_tokens = ft_strarr_len(tokens);
	if (num_tokens < 4 || num_tokens > 6)
		ft_error_exit("Error: Light format invalid.");
	light = (t_light *)malloc(sizeof(t_light));
	if (!light)
		ft_error_exit("Error: Memory allocation failed.");
	light->position = parse_vec3(tokens[1]);
	light->brightness = ft_atod(tokens[2]);
	if (light->brightness < 0.0 || light->brightness > 1.0)
		ft_error_exit("Error: brightness must be between 0.0 and 1.0.");
	light->color = parse_vec3_color(tokens[3]);
	light->movement_type = MOVEMENT_NONE;
	if (num_tokens >= 5)
	{
		parse_light_movement(light, tokens, num_tokens);
	}
	add_light_to_scene(scene, light);
}

// Parser de Luz Ambiental (A)
void	parse_ambient(t_scene *scene, char **tokens)
{
	t_vec3	color;
	double	ratio;

	if (scene->has_ambient)
		ft_error_exit("Error: Multiple ambient lights not allowed");
	if (ft_strarr_len(tokens) != 3)
		ft_error_exit("Error: Ambient light format invalid");
	ratio = ft_atod(tokens[1]);
	if (ratio < 0.0 || ratio > 1.0)
		ft_error_exit("Error: Ambient ratio must be betwen 0.0 and 1.0");
	color = parse_vec3_color(tokens[2]);
	scene->ambient.ratio = ratio;
	scene->ambient.color = color;
	scene->has_ambient = 1;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_elements.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minirt.h"

// Parser de Esfera (sp)
void	parse_sphere(t_scene *scene, char **tokens)
{
	t_sphere	*sp;
	t_object	*obj;

	if (ft_strarr_len(tokens) < 4)
		ft_error_exit("Error: Sphere format invalid");
	sp = (t_sphere *)malloc(sizeof(t_sphere));
	if (!sp)
		ft_error_exit("Error: Memory allocation failed");
	sp->center = parse_vec3(tokens[1]);
	sp->radius = parse_positive_double(tokens[2]);
	obj = create_object(SPHERE, sp, parse_vec3_color(tokens[3]));
	apply_object_modifiers(obj, tokens, 4);
	add_object_to_scene(scene, obj);
}

// Parser de Plano (pl)
void	parse_plane(t_scene *scene, char **tokens)
{
	t_plane		*pl;
	t_object	*obj;

	if (ft_strarr_len(tokens) < 4)
		ft_error_exit("Error: Plane format invalid");
	pl = (t_plane *)malloc(sizeof(t_plane));
	if (!pl)
		ft_error_exit("Error: Memory allocation failed");
	pl->position = parse_vec3(tokens[1]);
	pl->normal = parse_vec3_normalized(tokens[2]);
	obj = create_object(PLANE, pl, parse_vec3_color(tokens[3]));
	apply_object_modifiers(obj, tokens, 4);
	add_object_to_scene(scene, obj);
}

// Parser de Cilindro (cy)
void	parse_cylinder(t_scene *scene, char **tokens)
{
	t_cylinder	*cy;
	t_object	*obj;

	if (ft_strarr_len(tokens) < 6)
		ft_error_exit("Error: Cylinder format invalid");
	cy = (t_cylinder *)malloc(sizeof(t_cylinder));
	if (!cy)
		ft_error_exit("Error: Memory allocation failed");
	cy->position = parse_vec3(tokens[1]);
	cy->axis = parse_vec3_normalized(tokens[2]);
	cy->radius = parse_positive_double(tokens[3]);
	cy->height = parse_positive_double(tokens[4]);
	obj = create_object(CYLINDER, cy, parse_vec3_color(tokens[5]));
	apply_object_modifiers(obj, tokens, 6);
	add_object_to_scene(scene, obj);
}

// Parser de Cono (cn)
void	parse_cone(t_scene *scene, char **tokens)
{
	t_cone		*cn;
	t_object	*obj;

	if (ft_strarr_len(tokens) < 6)
		ft_error_exit("Error: Cone format invalid");
	cn = malloc(sizeof(t_cone));
	if (!cn)
		ft_error_exit("Error: Memory allocation failed");
	cn->position = parse_vec3(tokens[1]);
	cn->axis = parse_vec3_normalized(tokens[2]);
	cn->radius = parse_positive_double(tokens[3]);
	cn->height = parse_positive_double(tokens[4]);
	obj = create_object(CONE, cn, parse_vec3_color(tokens[5]));
	apply_object_modifiers(obj, tokens, 6);
	add_object_to_scene(scene, obj);
}

// Parser de Paraboloide (pb) ->bonus
void	parse_paraboloid(t_scene *scene, char **tokens)
{
	t_parab		*pb;
	t_object	*obj;

	if (ft_strarr_len(tokens) < 6)
		ft_error_exit("Error: Cone format invalid");
	pb = malloc(sizeof(t_parab));
	if (!pb)
		ft_error_exit("Error: Memory allocation failed");
	pb->position = parse_vec3(tokens[1]);
	pb->axis = parse_vec3_normalized(tokens[2]);
	pb->focal_lenght = parse_positive_double(tokens[3]);
	pb->height = parse_positive_double(tokens[4]);
	obj = create_object(PARABOLOID, pb, parse_vec3_color(tokens[5]));
	apply_object_modifiers(obj, tokens, 6);
	add_object_to_scene(scene, obj);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_utils_2.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

// Nueva versión: esta función devuelve 1 si es un entero válido, 0 si no.
int	validate_is_integer(char *str)
{
	int	i;

	i = 0;
	if (!str || str[0] == '\0')
		return (0);
	while (str[i])
	{
		if (!ft_isdigit((unsigned char)str[i]))
			return (0);
		i++;
	}
	return (1);
}

// Nueva versión: ahora la lógica es lineal y segura
double	validate_color_component(char *str)
{
	char	*trimmed;
	int		v;

	trimmed = ft_strtrim(str, " \r\t\n");
	if (!trimmed)
		ft_error_exit("MiniRT: Error: allocating memory in color parser");
	if (!validate_is_integer(trimmed))
	{
		free(trimmed);
		ft_error_exit("MiniRT: Error: color components must be valid integers");
	}
	if (trimmed[0] == '\0')
	{
		free(trimmed);
		ft_error_exit("MiniRT: Error: color component is empty");
	}
	v = ft_atoi(trimmed);
	if (v < 0 || v > 255)
	{
		free(trimmed);
		ft_error_exit("MiniRT: Error: Color values must be in range 0–255");
	}
	free(trimmed);
	return (v / 255.0);
}

int	ft_strarr_len(char **arr)
{
	int	len;

	len = 0;
	if (!arr)
		return (0);
	while (arr[len])
		len++;
	return (len);
}

static double	parse_integer_part(const char **str, int *sign)
{
	double	result;

	result = 0.0;
	if (**str == '-')
	{
		*sign = -1;
		(*str)++;
	}
	while (**str && **str != '.')
	{
		result = result * 10.0 + (**str - '0');
		(*str)++;
	}
	return (result);
}

double	ft_atod(const char *str)
{
	double	result;
	double	decimal_part;
	int		sign;

	sign = 1;
	result = parse_integer_part(&str, &sign);
	decimal_part = 1.0;
	if (*str == '.')
	{
		str++;
		while (*str)
		{
			decimal_part /= 10.0;
			result = result + (*str - '0') * decimal_part;
			str++;
		}
	}
	return (result * sign);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_utils_3.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

// Añade un objeto de forma dinámica a la escena
void	add_object_to_scene(t_scene *scene, t_object *obj)
{
	int			count;
	t_object	**new_objects;

	count = 0;
	if (scene->objects)
	{
		while (((t_object **)scene->objects)[count])
			count++;
	}
	new_objects = (t_object **)malloc(sizeof(t_object *) * (count + 2));
	if (!new_objects)
		ft_error_exit("MiniRT: Error: Malloc failed for objects");
	if (scene->objects)
	{
		ft_memcpy(new_objects, scene->objects, sizeof(t_object *) * (count
				+ 1));
		free(scene->objects);
	}
	new_objects[count] = obj;
	new_objects[count + 1] = NULL;
	scene->objects = new_objects;
}

// Añade una luz de forma dinámica a la escena
void	add_light_to_scene(t_scene *scene, t_light *light)
{
	int		count;
	t_light	**new_lights;

	count = 0;
	if (scene->lights)
		while (((t_light **)scene->lights)[count])
			count++;
	new_lights = (t_light **)malloc(sizeof(t_light *) * (count + 2));
	if (!new_lights)
		ft_error_exit("MiniRT: Error: Malloc failed for lights");
	if (scene->lights)
	{
		ft_memcpy(new_lights, scene->lights, sizeof(t_light *) * (count + 1));
		free(scene->lights);
	}
	new_lights[count] = light;
	new_lights[count + 1] = NULL;
	scene->lights = new_lights;
	scene->num_lights++;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_utils.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minirt.h"

// Validadcion para los valores doubles que deben ser positivos
double	parse_positive_double(char *str)
{
	double	val;
	char	*trimmed;

	trimmed = ft_strtrim(str, " \t\r\n");
	if (!trimmed)
		ft_error_exit("MiniRT: Error: Memory allocation failed");
	if (trimmed[0] == '\0')
		ft_error_exit("MiniRT: Error: Empty numeric value");
	val = ft_atod(trimmed);
	free(trimmed);
	if (val <= 0)
		ft_error_exit("MiniRT: Error: Incorrect data values");
	return (val);
}

// Validacion del valor fov de la camara
double	parse_fov(char *str)
{
	double	fov;
	char	*trimmed;

	fov = 0.0;
	if (!str)
		ft_error_exit("MiniRT: Error: FOV string is NULL");
	trimmed = ft_strtrim(str, " \r\t\n");
	if (!trimmed)
		ft_error_exit("MiniRT: Error: allocating memory failed in parse_fov");
	fov = ft_atod(trimmed);
	free(trimmed);
	if (fov < 0 || fov > 180)
		ft_error_exit("MiniRT: Error: FOV must be in range (0, 180)");
	return (fov);
}

// Convierte un string "x,y,z" a un t_vec3
t_vec3	parse_vec3(char *str)
{
	t_vec3	vec;
	char	**coords;

	coords = ft_split(str, ',');
	if (ft_strarr_len(coords) != 3)
		ft_error_exit("MiniRT: Error: Invalid vector format");
	vec.x = ft_atod(coords[0]);
	vec.y = ft_atod(coords[1]);
	vec.z = ft_atod(coords[2]);
	ft_free_str_array(coords);
	return (vec);
}

// valida que el vector "x,y,z" se encuentre normalizado entre [-1,1]
t_vec3	parse_vec3_normalized(char *str)
{
	t_vec3	vec;
	char	**coords;

	if (!str)
		ft_error_exit("MiniRT: Error: color string is NULL");
	coords = ft_split(str, ',');
	if (ft_strarr_len(coords) != 3)
	{
		ft_free_str_array(coords);
		ft_error_exit("MiniRT: Error: Invalid vector format");
	}
	vec.x = ft_atod(coords[0]);
	vec.y = ft_atod(coords[1]);
	vec.z = ft_atod(coords[2]);
	ft_free_str_array(coords);
	if (vec.x < -1 || vec.x > 1
		|| vec.y < -1 || vec.y > 1
		|| vec.z < -1 || vec.z > 1)
		ft_error_exit("MiniRT: Error: Vector components\
			normalized must be between -1 and 1");
	return (vec);
}

t_vec3	parse_vec3_color(char *str)
{
	t_vec3	color;
	char	**rgb;

	if (!str)
		ft_error_exit("MiniRT: Error: color string is NULL");
	rgb = ft_split(str, ',');
	if (ft_strarr_len(rgb) != 3)
	{
		ft_free_str_array(rgb);
		ft_error_exit("MiniRT: Error: Invalid color format");
	}
	color.x = validate_color_component(rgb[0]);
	color.y = validate_color_component(rgb[1]);
	color.z = validate_color_component(rgb[2]);
	ft_free_str_array(rgb);
	return (color);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_utils_materials_2.c                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

char	*copy_trimmed_token(char *token, int len)
{
	char	*trimmed;
	int		i;

	trimmed = (char *)malloc(len + 1);
	if (!trimmed)
		ft_error_exit("MiniRT: Error: allocating memory for bmp");
	i = 0;
	while (i < len)
	{
		trimmed[i] = token[i];
		i++;
	}
	trimmed[i] = '\0';
	return (trimmed);
}

char	*parse_bump_map(char *token)
{
	char	*path;
	int		len;
	int		fd;

	if (!token)
		ft_error_exit("MiniRT: Error: bump map token is missing");
	token += 4;
	len = 0;
	while (token[len] && token[len] != '\n' && token[len] != '\r'
		&& token[len] != ' ' && token[len] != '\t')
		len++;
	if (len <= 4)
		ft_error_exit("MiniRT: Error: bump map path is empty");
	path = copy_trimmed_token(token, len);
	if (!validate_texture_extension(path))
	{
		free(path);
		ft_error_exit("MiniRT: Error:  texture file \
            must have .png or .xpm extension");
	}
	fd = open_filename(path);
	validate_file(fd, path);
	close(fd);
	return (path);
}

static void	parse_basic_modifiers(t_object *obj, char **tokens, int *i)
{
	if (ft_strncmp(tokens[*i], "spc:", 4) == 0)
		parse_specular(tokens[*i], &obj->material->specular);
	else if (ft_strncmp(tokens[*i], "mir:", 4) == 0)
		obj->material->mirror_ratio = parse_mirror(tokens[*i]);
	else if (ft_strncmp(tokens[*i], "chk:", 4) == 0)
		parse_checkboard(tokens[*i], obj->material);
}

static void	parse_texture_modifier(t_object *obj, char *token)
{
	char	*path;
	void	**img_ptr;
	bool	*flag_ptr;

	if (ft_strncmp(token, "bmp:", 4) == 0)
	{
		img_ptr = (void **)&obj->material->texture_img;
		flag_ptr = &obj->material->has_normal_map;
	}
	else if (ft_strncmp(token, "tex:", 4) == 0)
	{
		img_ptr = (void **)&obj->material->color_img;
		flag_ptr = &obj->material->has_texture;
	}
	else
		return ;
	path = ft_strtrim(token + 4, " \t\n\r");
	*img_ptr = mlx_load_png(path);
	if (!*img_ptr)
	{
		free(path);
		ft_error_exit("Error: Failed to load PNG texture.");
	}
	*flag_ptr = true;
	free(path);
}

void	apply_object_modifiers(t_object *obj, char **tokens, int start_idx)
{
	int	i;

	i = start_idx;
	while (tokens[i])
	{
		parse_basic_modifiers(obj, tokens, &i);
		parse_texture_modifier(obj, tokens[i]);
		i++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_utils_materials.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minirt.h"

int	valid_extension_rt(const char *filename)
{
	int	len;

	len = 0;
	while (filename[len] != '\0')
		len++;
	return (len > 3 && filename[len - 3] == '.' && filename[len - 2] == 'r'
		&& filename[len - 1] == 't');
}

void	parse_specular(char *token, t_specular *spec)
{
	char	**parts;

	parts = ft_split(token + 4, ',');
	if (ft_strarr_len(parts) != 2)
		ft_error_exit("Error: Invalid specular format");
	spec->intensity = ft_atod(parts[0]);
	spec->shininess = (int)ft_atod(parts[1]);
	ft_free_str_array(parts);
}

double	parse_mirror(char *token)
{
	return (ft_atod(token + 4));
}

void	parse_checkboard(char *token, t_material *material)
{
	char	**parts;

	parts = ft_split(token + 4, ';');
	if (ft_strarr_len(parts) != 3)
		ft_error_exit("MiniRT: Error: Invalid checkerboard format");
	material->check_color1 = parse_vec3_color(parts[0]);
	material->check_color2 = parse_vec3_color(parts[1]);
	material->check_scale = ft_atod(parts[2]);
	material->has_checkerboard = 1;
	ft_free_str_array(parts);
}

int	validate_texture_extension(const char *file_name)
{
	int	len;

	if (!file_name)
		return (0);
	len = 0;
	while (file_name[len])
		len++;
	if ((len >= 4 && file_name[len - 4] == '.') && (file_name[len - 3] == 'p')
		|| (file_name[len - 3] == 'P') && (file_name[len - 2] == 'n')
		|| (file_name[len - 2] == 'N') && (file_name[len - 1] == 'g')
		|| (file_name[len - 1] == 'G'))
		return (1);
	if (len >= 4 && file_name[len - 4] == '.' && (file_name[len - 3] == 'x')
		|| (file_name[len - 3] == 'X') && (file_name[len - 2] == 'p')
		|| (file_name[len - 2] == 'P') && (file_name[len - 1] == 'm')
		|| (file_name[len - 1] == 'M'))
		return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   animate_lights.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minirt.h"

// Maneja la animación de la luz en un movimiento circular
static void	animate_circular(t_light *light, double time)
{
	double	radius;
	double	speed;

	radius = 10.0;
	speed = 1.0;
	light->position.x = radius * cos(time * speed);
	light->position.z = radius * sin(time * speed);
}

// Maneja la animación de la luz en un movimiento lineal de un lado a otro
static void	animate_linear(t_light *light, double time)
{
	double	start_pos;
	double	end_pos;
	double	travel_range;
	double	speed;

	start_pos = -10.0;
	end_pos = 10.0;
	travel_range = end_pos - start_pos;
	speed = 0.5;
	light->position.x = start_pos + travel_range * 0.5 * (1 + sin(time
				* speed));
}

// Maneja la animación de la luz en un movimiento triangular
static void	animate_triangular(t_light *light, double time)
{
	double	side_length;
	t_vec3	p1;
	t_vec3	p2;
	t_vec3	p3;
	double	normalized_time;

	side_length = 15.0;
	p1 = vec3_init(0, 0, 0);
	p2 = vec3_init(side_length, 0, 0);
	p3 = vec3_init(side_length / 2, 0, side_length * sin(M_PI / 3));
	normalized_time = fmod(time, 3.0);
	if (normalized_time < 1.0)
		light->position = vec3_add(p1, vec3_mul(vec3_sub(p2, p1),
					normalized_time));
	else if (normalized_time < 2.0)
		light->position = vec3_add(p2, vec3_mul(vec3_sub(p3, p2),
					normalized_time - 1.0));
	else
		light->position = vec3_add(p3, vec3_mul(vec3_sub(p1, p3),
					normalized_time - 2.0));
}

// Función principal de animación de luces
void	animate_lights(void *param)
{
	t_data	*data;
	t_light	**lights;
	int		i;

	data = (t_data *)param;
	if (!data->scene.lights || data->scene.num_lights == 0)
		return ;
	lights = (t_light **)data->scene.lights;
	data->light_move_time += 0.05;
	i = 0;
	while (i < data->scene.num_lights)
	{
		if (lights[i]->movement_type == MOVEMENT_CIRCLE)
			animate_circular(lights[i], data->light_move_time);
		else if (lights[i]->movement_type == MOVEMENT_TRIANGLE)
			animate_triangular(lights[i], data->light_move_time);
		else if (lights[i]->movement_type == MOVEMENT_LINE)
			animate_linear(lights[i], data->light_move_time);
		i++;
	}
	render_threaded(data);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   auto_rotate.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

void	auto_rotate(void *param)
{
	t_data	*data;
	double	radius;
	t_vec3	center;

	data = (t_data *)param;
	if (!data->auto_rotate_active)
		return ;
	data->rotation_angle += 0.01;
	if (data->rotation_angle > 2 * M_PI)
		data->rotation_angle -= 2 * M_PI;
	radius = 10.0;
	center = vec3_init(0, 0, 0);
	data->scene.camera.position.x = center.x + radius
		* cos(data->rotation_angle);
	data->scene.camera.position.z = center.z + radius
		* sin(data->rotation_angle);
	data->scene.camera.forward = vec3_normalize(vec3_sub(center,
				data->scene.camera.position));
	data->scene.camera.right = vec3_normalize(vec3_cross(
				data->scene.camera.forward, (t_vec3){0, 1, 0}));
	data->scene.camera.up = vec3_normalize(vec3_cross(data->scene.camera.right,
				data->scene.camera.forward));
	render_threaded(data);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_color.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minirt.h"

// src/render/ft_color.c
t_color	get_object_color(t_hit_record *rec)
{
	t_vec3	local_point;

	if (!rec->object->material)
		return (rec->object->color);
	if (rec->object->material->has_texture)
		return (get_texture_color(rec));
	else if (rec->object->material->has_checkerboard)
	{
		local_point = rec->point;
		if (((int)floor(local_point.x / rec->object->material->check_scale)
				+ (int)floor(local_point.y / rec->object->material->check_scale)
				+ (int)floor(local_point.z
					/ rec->object->material->check_scale)) % 2 == 0)
			return (rec->object->material->check_color1);
		else
			return (rec->object->material->check_color2);
	}
	else
		return (rec->object->color);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_normal_mapping.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

// src/render/ft_normal_mapping.c
t_mat3	create_tbn_matrix(t_vec3 normal)
{
	t_vec3	tangent;
	t_vec3	bitangent;
	t_vec3	up;
	t_mat3	tbn;

	up = vec3_init(0.0, 1.0, 0.0);
	if (fabs(vec3_dot(normal, up)) > 0.999)
		up = vec3_init(1.0, 0.0, 0.0);
	tangent = vec3_normalize(vec3_cross(up, normal));
	bitangent = vec3_normalize(vec3_cross(normal, tangent));
	tbn.c1 = tangent;
	tbn.c2 = bitangent;
	tbn.c3 = normal;
	return (tbn);
}

// src/render/ft_normal_map.c
t_vec3	get_normal_from_texture(t_hit_record *rec, mlx_texture_t *normal_map)
{
	t_vec2	uv;
	int		x_tex;
	int		y_tex;
	int		index;
	t_vec3	new_normal;

	uv = get_texture_uv(rec);
	x_tex = (int)(uv.x * (normal_map->width - 1));
	y_tex = (int)(uv.y * (normal_map->height - 1));
	index = (y_tex * normal_map->width + x_tex) * 4;
	new_normal.x = (double)normal_map->pixels[index] / 127.5 - 1.0;
	new_normal.y = (double)normal_map->pixels[index + 1] / 127.5 - 1.0;
	new_normal.z = (double)normal_map->pixels[index + 2] / 127.5 - 1.0;
	return (vec3_normalize(new_normal));
}

// src/render/ft_normal_map.c
t_vec3	get_normal_from_map(t_hit_record *rec, t_vec3 geom_normal)
{
	mlx_texture_t	*normal_map;
	t_vec3			new_normal;
	t_mat3			tbn;

	normal_map = rec->object->material->texture_img;
	if (!normal_map || normal_map->width <= 0 || normal_map->height <= 0)
		return (geom_normal);
	new_normal = get_normal_from_texture(rec, normal_map);
	tbn = create_tbn_matrix(geom_normal);
	new_normal = vec3_add(vec3_add(vec3_mul(tbn.c1, new_normal.x),
				vec3_mul(tbn.c2, new_normal.y)), vec3_mul(tbn.c3,
				new_normal.z));
	return (vec3_normalize(new_normal));
}

// Obtiene la normal de la textura y la convierte a espacio del mundo
// t_vec3	get_normal_from_map(t_hit_record *rec, t_vec3 geom_normal)
// {
// 	t_vec2			uv;
// 	mlx_texture_t	*normal_map;
// 	int				x_tex;
// 	int				y_tex;
// 	int				index;
// 	t_vec3			new_normal;
// 	t_mat3			tbn;

// 	normal_map = rec->object->material->texture_img;
// 	if (!normal_map || normal_map->width <= 0 || normal_map->height <= 0)
// 		return (geom_normal);
// 	if (rec->object->type == SPHERE)
// 		uv = get_uv_sphere(rec);
// 	else if (rec->object->type == PLANE)
// 		uv = get_uv_plane(rec);
// 	else if (rec->object->type == CYLINDER)
// 		uv = get_uv_cylinder(rec);
// 	else if (rec->object->type == CONE)
// 		uv = get_uv_cone(rec);
// 	else if (rec->object->type == HYPERBOLOID)
// 		uv = get_uv_hyperboloid(rec);
// 	else if (rec->object->type == PARABOLOID)
// 		uv = get_uv_paraboloid(rec);
// 	else
// 		return (geom_normal);
// 	x_tex = (int)(uv.x * (normal_map->width - 1));
// 	y_tex = (int)(uv.y * (normal_map->height - 1));
// 	index = (y_tex * normal_map->width + x_tex) * 4;
// 	new_normal.x = (double)normal_map->pixels[index] / 127.5 - 1.0;
// 	new_normal.y = (double)normal_map->pixels[index + 1] / 127.5 - 1.0;
// 	new_normal.z = (double)normal_map->pixels[index + 2] / 127.5 - 1.0;
// 	new_normal = vec3_normalize(new_normal);
// 	tbn = create_tbn_matrix(geom_normal);
// 	new_normal = vec3_add(vec3_add(vec3_mul(tbn.c1, new_normal.x),
// 				vec3_mul(tbn.c2, new_normal.y)), vec3_mul(tbn.c3,
// 				new_normal.z));
// 	return (vec3_normalize(new_normal));
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_ray.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

t_ray_data	calculate_ray_data(t_subpixel_data sp, t_scene *scene)
{
	t_ray_data	data;

	data.fov_rad = scene->camera.fov * M_PI / 180.0;
	data.aspect_ratio = (double)scene->width / (double)scene->height;
	data.camera_right = vec3_normalize(vec3_cross(scene->camera.orientation,
				vec3_init(0.0, 1.0, 0.0)));
	data.camera_up = vec3_normalize(vec3_cross(data.camera_right,
				scene->camera.orientation));
	data.x_coord_normalized = ((double)sp.x + ((double)sp.sub_x + 0.5)
			/ SUBPIXEL_SAMPLES) / scene->width - 0.5;
	data.y_coord_normalized = 0.5 - ((double)sp.y + ((double)sp.sub_y + 0.5)
			/ SUBPIXEL_SAMPLES) / scene->height;
	data.viewport_center = vec3_add(scene->camera.position,
			vec3_mul(scene->camera.orientation, 1.0));
	return (data);
}

t_ray	generate_antialiased_ray(t_subpixel_data sp, t_scene *scene)
{
	t_ray		ray;
	t_ray_data	data;
	t_vec3		direction;

	data = calculate_ray_data(sp, scene);
	ray.origin = scene->camera.position;
	direction = vec3_add(vec3_add(data.viewport_center,
				vec3_mul(data.camera_right, 2.0 * tan(data.fov_rad / 2.0)
					* data.aspect_ratio * data.x_coord_normalized)),
			vec3_mul(data.camera_up, 2.0 * tan(data.fov_rad / 2.0)
				* data.y_coord_normalized));
	ray.direction = vec3_sub(direction, ray.origin);
	ray.direction = vec3_normalize(ray.direction);
	return (ray);
}
// t_ray	generate_antialiased_ray(int x, int y, int sub_x, int sub_y,
// 		t_scene *scene)
// {
// 	t_ray	ray;
// 	t_vec3	camera_right;
// 	t_vec3	camera_up;
// 	t_vec3	viewport_center;
// 	double	aspect_ratio;
// 	double	fov_rad;
// 	double	x_coord_normalized;
// 	double	y_coord_normalized;

// 	ray.origin = scene->camera.position;
// 	fov_rad = scene->camera.fov * M_PI / 180.0;
// 	aspect_ratio = (double)scene->width / (double)scene->height;
// 	camera_up = vec3_init(0.0, 1.0, 0.0);
// 	camera_right = vec3_normalize(vec3_cross(scene->camera.orientation,
// 				camera_up));
// 	camera_up = vec3_normalize(vec3_cross(camera_right,
// 				scene->camera.orientation));
// 	x_coord_normalized = ((double)x + ((double)sub_x + 0.5) / SUBPIXEL_SAMPLES)
// 		/ scene->width - 0.5;
// 	y_coord_normalized = 0.5 - ((double)y + ((double)sub_y + 0.5)
// 			/ SUBPIXEL_SAMPLES) / scene->height;
// 	viewport_center = vec3_add(scene->camera.position,
// 			vec3_mul(scene->camera.orientation, 1.0));
// 	ray.direction = vec3_add(vec3_add(viewport_center, vec3_mul(camera_right,
// 					2.0 * tan(fov_rad / 2.0) * aspect_ratio
// 					* x_coord_normalized)), vec3_mul(camera_up, 2.0
// 				* tan(fov_rad / 2.0) * y_coord_normalized));
// 	ray.direction = vec3_sub(ray.direction, ray.origin);
// 	ray.direction = vec3_normalize(ray.direction);
// 	return (ray);
// }

t_hit_record	get_intersection(t_ray *ray, t_object *object)
{
	t_hit_record	current_hit;

	current_hit.t = -1.0;
	if (object->type == SPHERE)
		intersect_sphere(ray, (t_sphere *)object->data, &current_hit);
	else if (object->type == PLANE)
		intersect_plane(ray, (t_plane *)object->data, &current_hit);
	else if (object->type == CYLINDER)
		intersect_cylinder(ray, (t_cylinder *)object->data, &current_hit);
	else if (object->type == CONE)
		intersect_cone(ray, (t_cone *)object->data, &current_hit);
	else if (object->type == HYPERBOLOID)
		intersect_hyperboloid(ray, (t_hyperboloid *)object->data, &current_hit);
	else if (object->type == PARABOLOID)
		intersect_paraboloid(ray, (t_parab *)object->data, &current_hit);
	return (current_hit);
}

// src/ft_ray.c
t_hit_record	find_closest_hit(t_ray *ray, t_scene *scene)
{
	t_hit_record	closest_hit;
	t_object		**objects;
	double			min_t;
	int				i;
	t_hit_record	current_hit;

	objects = (t_object **)scene->objects;
	min_t = -1.0;
	i = 0;
	closest_hit.object = NULL;
	if (!objects)
		return (closest_hit);
	while (objects[i] != NULL)
	{
		current_hit = get_intersection(ray, objects[i]);
		if (current_hit.t > EPSILON && (min_t < 0 || current_hit.t < min_t))
		{
			min_t = current_hit.t;
			closest_hit = current_hit;
			closest_hit.object = objects[i];
			closest_hit.ray = *ray;
		}
		i++;
	}
	return (closest_hit);
}

// t_hit_record find_closest_hit(t_ray *ray, t_scene *scene)
// {
//     t_hit_record    closest_hit;
//     t_hit_record    current_hit;
//     t_object        **objects = (t_object **)scene->objects;
//     double          min_t = -1.0;
//     int             i = 0;

//     closest_hit.object = NULL;
//     if (!objects)
//         return (closest_hit);
//     while (objects[i] != NULL)
//     {
//         current_hit.t = -1.0;
//         if (objects[i]->type == SPHERE)
//             intersect_sphere(ray, (t_sphere *)objects[i]->data,
// &current_hit);
//         else if (objects[i]->type == PLANE)
//             intersect_plane(ray, (t_plane *)objects[i]->data, &current_hit);
//         else if (objects[i]->type == CYLINDER)
//             intersect_cylinder(ray, (t_cylinder *)objects[i]->data,
// &current_hit);
//         else if (objects[i]->type == CONE)
//             intersect_cone(ray, (t_cone *)objects[i]->data, &current_hit);
//         else if (objects[i]->type == HYPERBOLOID)
//             intersect_hyperboloid(ray, (t_hyperboloid *)objects[i]->data,
// &current_hit);
//         else if (objects[i]->type == PARABOLOID)
//             intersect_paraboloid(ray, (t_parab *)objects[i]->data,
// &current_hit);
//         if (current_hit.t > EPSILON && (min_t < 0 || current_hit.t < min_t))
//         {
//             min_t = current_hit.t;
//             closest_hit = current_hit;
//             closest_hit.object = objects[i];
//             closest_hit.ray = *ray;
//         }
//         i++;
//     }
//     return (closest_hit);
// }/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_cone.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

t_cone_params	get_cone_quadratic(t_ray *ray, t_cone *cn)
{
	t_cone_params	p;
	double			cone_cos2;

	p.oc = vec3_sub(ray->origin, cn->position);
	cone_cos2 = pow(cn->radius / (cn->height / 2.0), 2.0);
	p.a = vec3_dot(ray->direction, ray->direction) - (1 + cone_cos2)
		* pow(vec3_dot(ray->direction, cn->axis), 2);
	p.b = 2.0 * (vec3_dot(ray->direction, p.oc) - (1 + cone_cos2)
			* vec3_dot(ray->direction, cn->axis) * vec3_dot(p.oc, cn->axis));
	p.c = vec3_dot(p.oc, p.oc) - (1 + cone_cos2) * pow(vec3_dot(p.oc, cn->axis),
			2);
	return (p);
}

double	get_cone_t(t_ray *ray, t_cone *cn, t_cone_params p)
{
	double	disc;
	double	t1;
	double	t2;
	double	m1;
	double	m2;

	disc = p.b * p.b - 4.0 * p.a * p.c;
	if (disc < 0.0)
		return (-1.0);
	t1 = (-p.b - sqrt(disc)) / (2.0 * p.a);
	t2 = (-p.b + sqrt(disc)) / (2.0 * p.a);
	m1 = vec3_dot(ray->direction, cn->axis) * t1 + vec3_dot(p.oc, cn->axis);
	m2 = vec3_dot(ray->direction, cn->axis) * t2 + vec3_dot(p.oc, cn->axis);
	if (t1 > EPSILON && m1 > 0 && m1 < cn->height)
	{
		if (t2 > EPSILON && m2 > 0 && m2 < cn->height)
			return (fmin(t1, t2));
		return (t1);
	}
	if (t2 > EPSILON && m2 > 0 && m2 < cn->height)
		return (t2);
	return (-1.0);
}

int	intersect_cone(t_ray *ray, t_cone *cn, t_hit_record *rec)
{
	t_cone_params	p;
	double			t;
	double			m;

	p = get_cone_quadratic(ray, cn);
	if (p.a == 0 && p.b == 0)
		return (0);
	t = get_cone_t(ray, cn, p);
	if (t > EPSILON)
	{
		m = vec3_dot(ray->direction, cn->axis) * t + vec3_dot(p.oc, cn->axis);
		rec->t = t;
		rec->point = ray_at(*ray, rec->t);
		rec->normal = vec3_normalize(vec3_sub(vec3_sub(rec->point,
						cn->position), vec3_mul(cn->axis, m)));
		if (vec3_dot(rec->normal, ray->direction) > 0)
			rec->normal = vec3_mul(rec->normal, -1.0);
		return (1);
	}
	return (0);
}

// int intersect_cone(t_ray *ray, t_cone *cn, t_hit_record *rec)
// {
//     t_vec3  oc = vec3_sub(ray->origin, cn->position);
//     double  cone_cos2 = pow(cn->radius / (cn->height / 2.0), 2.0);
//     double a = vec3_dot(ray->direction, ray->direction) - (1 + cone_cos2)
// * pow(vec3_dot(ray->direction, cn->axis), 2);
//     double b = 2.0 * (vec3_dot(ray->direction, oc) - (1 + cone_cos2)
// * vec3_dot(ray->direction, cn->axis) * vec3_dot(oc, cn->axis));
//     double c = vec3_dot(oc, oc) - (1 + cone_cos2) * pow(vec3_dot(oc,
// cn->axis), 2);
//     double discriminant = b * b - 4.0 * a * c;
//     if (discriminant < 0.0)
//         return (0);
//     double t1 = (-b - sqrt(discriminant)) / (2.0 * a);
//     double t2 = (-b + sqrt(discriminant)) / (2.0 * a);
//     double m1 = vec3_dot(ray->direction, cn->axis) * t1 + vec3_dot(oc,
// cn->axis);
//     double m2 = vec3_dot(ray->direction, cn->axis) * t2 + vec3_dot(oc,
// cn->axis);
//     rec->t = -1.0;
//     if (t1 > EPSILON && m1 > 0 && m1 < cn->height)
//         rec->t = t1;
//     if (t2 > EPSILON && m2 > 0 && m2 < cn->height)
//     {
//         if (rec->t < 0 || t2 < rec->t)
//             rec->t = t2;
//     }
//     if (rec->t > EPSILON)
//     {
//         double m = vec3_dot(ray->direction, cn->axis) * rec->t + vec3_dot(oc,
// cn->axis);
//         rec->point = ray_at(*ray, rec->t);
//         rec->normal = vec3_normalize(vec3_sub(vec3_sub(rec->point,
// cn->position), vec3_mul(cn->axis, m * (1 + cone_cos2))));
//         if (vec3_dot(rec->normal, ray->direction) > 0)
//             rec->normal = vec3_mul(rec->normal, -1);
//         return (1);
//     }
//     return (0);
// }/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_cylinder.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

// Intersecta el rayo con los lados del cilindro.
static int	intersect_sides(t_ray *ray, t_cylinder *cy, t_hit_record *rec)
{
	t_vec3			oc;
	t_vec3			coeffs;
	t_hit_params	params;
	double			discriminant;
	double			t_side;

	oc = vec3_sub(ray->origin, cy->position);
	coeffs = calculate_quadratic_coeffs(ray, oc, cy);
	discriminant = coeffs.y * coeffs.y - 4 * coeffs.x * coeffs.z;
	if (discriminant < 0)
		return (0);
	params.ray = ray;
	params.cy = cy;
	params.oc = oc;
	t_side = (-coeffs.y - sqrt(discriminant)) / (2.0 * coeffs.x);
	if (check_hit_and_update_rec(&params, rec, t_side))
		return (1);
	t_side = (-coeffs.y + sqrt(discriminant)) / (2.0 * coeffs.x);
	if (check_hit_and_update_rec(&params, rec, t_side))
		return (1);
	return (0);
}

// Calcula la intersección con una sola tapa del cilindro.
static double	calculate_cap_intersection(t_ray *ray, t_cylinder *cy,
		t_vec3 cap_center)
{
	double	denom;
	double	t;
	t_vec3	p;

	denom = vec3_dot(ray->direction, cy->axis);
	if (fabs(denom) < EPSILON)
		return (-1.0);
	t = vec3_dot(vec3_sub(cap_center, ray->origin), cy->axis) / denom;
	if (t < EPSILON)
		return (-1.0);
	p = ray_at(*ray, t);
	if (vec3_length_squared(vec3_sub(p, cap_center)) > cy->radius * cy->radius)
		return (-1.0);
	return (t);
}

// Intersecta el rayo con las tapas del cilindro.
static int	intersect_caps(t_ray *ray, t_cylinder *cy, double *t_cap,
		t_hit_record *rec)
{
	t_vec3	top_center;
	t_vec3	bottom_center;
	double	t_top;
	double	t_bottom;

	top_center = vec3_add(cy->position, vec3_mul(cy->axis, cy->height / 2.0));
	t_top = calculate_cap_intersection(ray, cy, top_center);
	bottom_center = vec3_add(cy->position, vec3_mul(cy->axis, -cy->height
				/ 2.0));
	t_bottom = calculate_cap_intersection(ray, cy, bottom_center);
	*t_cap = -1.0;
	if (t_top > EPSILON && (t_bottom < EPSILON || t_top < t_bottom))
		*t_cap = t_top;
	else if (t_bottom > EPSILON)
		*t_cap = t_bottom;
	if (*t_cap > EPSILON)
	{
		rec->point = ray_at(*ray, *t_cap);
		if (vec3_dot(ray->direction, cy->axis) > 0)
			rec->normal = vec3_mul(cy->axis, -1.0);
		else
			rec->normal = cy->axis;
		return (1);
	}
	return (0);
}

static void	select_closest_hit(t_hit_record *rec, t_closest_hit_data hit_data)
{
	if (hit_data.side_found && hit_data.cap_found)
	{
		if (hit_data.side_hit.t < hit_data.cap_hit.t)
			*rec = hit_data.side_hit;
		else
			*rec = hit_data.cap_hit;
	}
	else if (hit_data.side_found)
		*rec = hit_data.side_hit;
	else if (hit_data.cap_found)
		*rec = hit_data.cap_hit;
}

int	intersect_cylinder(t_ray *ray, t_cylinder *cy, t_hit_record *rec)
{
	t_closest_hit_data	hit_data;

	hit_data.side_found = intersect_sides(ray, cy, &hit_data.side_hit);
	hit_data.cap_found = intersect_caps(ray, cy, &hit_data.cap_hit.t,
			&hit_data.cap_hit);
	if (!hit_data.side_found && !hit_data.cap_found)
		return (0);
	select_closest_hit(rec, hit_data);
	return (1);
}

// // src/intersect/ft_cylinder.c
// static int	intersect_caps(t_ray *ray, t_cylinder *cy, double *t_cap,
// 		t_hit_record *rec)
// {
// 	double	denom;

// 	double t_top, t_bottom;
// 	t_vec3 p_top, p_bottom;
// 	denom = vec3_dot(ray->direction, cy->axis);
// 	if (fabs(denom) < EPSILON)
// 		t_top = -1.0;
// 	else
// 		t_top = vec3_dot(vec3_sub(vec3_add(cy->position, vec3_mul(cy->axis,
// 							cy->height / 2.0)), ray->origin), cy->axis) / denom;
// 	p_top = ray_at(*ray, t_top);
// 	if (t_top > EPSILON && vec3_length_squared(vec3_sub(p_top,
// 				vec3_add(cy->position, vec3_mul(cy->axis, cy->height
// 						/ 2.0)))) <= cy->radius * cy->radius)
// 		*t_cap = t_top;
// 	else
// 		*t_cap = -1.0;
// 	if (fabs(denom) < EPSILON)
// 		t_bottom = -1.0;
// 	else
// 		t_bottom = vec3_dot(vec3_sub(vec3_add(cy->position, vec3_mul(cy->axis,
// 							-cy->height / 2.0)), ray->origin), cy->axis)
// 			/ denom;
// 	p_bottom = ray_at(*ray, t_bottom);
// 	if (t_bottom > EPSILON && vec3_length_squared(vec3_sub(p_bottom,
// 				vec3_add(cy->position, vec3_mul(cy->axis, -cy->height
// 						/ 2.0)))) <= cy->radius * cy->radius)
// 	{
// 		if (*t_cap < 0 || t_bottom < *t_cap)
// 			*t_cap = t_bottom;
// 	}
// 	if (*t_cap > EPSILON)
// 	{
// 		rec->point = ray_at(*ray, *t_cap);
// 		if (denom > 0)
// 			rec->normal = vec3_mul(cy->axis, -1.0);
// 		else
// 			rec->normal = cy->axis;
// 		return (1);
// 	}
// 	return (0);
// }

// // src/intersect/ft_cylinder.c
// static int	intersect_sides(t_ray *ray, t_cylinder *cy, t_hit_record *rec)
// {
// 	double	discriminant;
// 	double	t_side;
// 	t_vec3	oc;
// 	double	m;
// 	double	m;

// 	double a, b, c;
// 	oc = vec3_sub(ray->origin, cy->position);
// 	a = vec3_dot(vec3_sub(ray->direction, vec3_mul(cy->axis,
// 					vec3_dot(ray->direction, cy->axis))),
// 			vec3_sub(ray->direction, vec3_mul(cy->axis, vec3_dot(ray->direction,
// 						cy->axis))));
// 	b = 2.0 * vec3_dot(vec3_sub(ray->direction, vec3_mul(cy->axis,
// 					vec3_dot(ray->direction, cy->axis))), vec3_sub(oc,
// 				vec3_mul(cy->axis, vec3_dot(oc, cy->axis))));
// 	c = vec3_dot(vec3_sub(oc, vec3_mul(cy->axis, vec3_dot(oc, cy->axis))),
// 			vec3_sub(oc, vec3_mul(cy->axis, vec3_dot(oc, cy->axis))))
// 		- (cy->radius * cy->radius);
// 	discriminant = b * b - 4 * a * c;
// 	if (discriminant < 0)
// 		return (0);
// 	t_side = (-b - sqrt(discriminant)) / (2.0 * a);
// 	if (t_side > EPSILON)
// 	{
// 		m = vec3_dot(ray->direction, cy->axis) * t_side + vec3_dot(oc,
// 				cy->axis);
// 		if (m >= -cy->height / 2.0 && m <= cy->height / 2.0)
// 		{
// 			rec->t = t_side;
// 			rec->point = ray_at(*ray, rec->t);
// 			rec->normal = vec3_normalize(vec3_sub(rec->point,
// 						vec3_add(cy->position, vec3_mul(cy->axis, m))));
// 			return (1);
// 		}
// 	}
// 	t_side = (-b + sqrt(discriminant)) / (2.0 * a);
// 	if (t_side > EPSILON)
// 	{
// 		m = vec3_dot(ray->direction, cy->axis) * t_side + vec3_dot(oc,
// 				cy->axis);
// 		if (m >= -cy->height / 2.0 && m <= cy->height / 2.0)
// 		{
// 			rec->t = t_side;
// 			rec->point = ray_at(*ray, rec->t);
// 			rec->normal = vec3_normalize(vec3_sub(rec->point,
// 						vec3_add(cy->position, vec3_mul(cy->axis, m))));
// 			return (1);
// 		}
// 	}
// 	return (0);
// }

// // src/intersect/ft_cylinder.c
// int	intersect_cylinder(t_ray *ray, t_cylinder *cy, t_hit_record *rec)
// {
// 	t_hit_record	side_hit;
// 	t_hit_record	cap_hit;
// 	int				side_found;
// 	int				cap_found;

// 	side_found = intersect_sides(ray, cy, &side_hit);
// 	cap_found = intersect_caps(ray, cy, &cap_hit.t, &cap_hit);
// 	if (side_found && cap_found)
// 	{
// 		if (side_hit.t < cap_hit.t)
// 			*rec = side_hit;
// 		else
// 			*rec = cap_hit;
// 		return (1);
// 	}
// 	else if (side_found)
// 	{
// 		*rec = side_hit;
// 		return (1);
// 	}
// 	else if (cap_found)
// 	{
// 		*rec = cap_hit;
// 		return (1);
// 	}
// 	return (0);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_cylinder.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

// Calcula los coeficientes de la ecuación cuadrática del cilindro.
t_vec3	calculate_quadratic_coeffs(t_ray *ray, t_vec3 oc, t_cylinder *cy)
{
	t_vec3	coeffs;
	t_vec3	v_a;
	t_vec3	v_b;

	v_a = vec3_sub(ray->direction, vec3_mul(cy->axis, vec3_dot(ray->direction,
					cy->axis)));
	coeffs.x = vec3_dot(v_a, v_a);
	v_b = vec3_sub(oc, vec3_mul(cy->axis, vec3_dot(oc, cy->axis)));
	coeffs.y = 2.0 * vec3_dot(v_a, v_b);
	coeffs.z = vec3_dot(v_b, v_b) - (cy->radius * cy->radius);
	return (coeffs);
}

// Comprueba si un t_side es un hit válido y actualiza el registro de hit.
int	check_hit_and_update_rec(t_hit_params *params, t_hit_record *rec,
		double t_side)
{
	double	m;

	if (t_side > EPSILON)
	{
		m = vec3_dot(params->ray->direction, params->cy->axis) * t_side
			+ vec3_dot(params->oc, params->cy->axis);
		if (m >= -params->cy->height / 2.0 && m <= params->cy->height / 2.0)
		{
			rec->t = t_side;
			rec->point = ray_at(*params->ray, rec->t);
			rec->normal = vec3_normalize(vec3_sub(rec->point,
						vec3_add(params->cy->position,
							vec3_mul(params->cy->axis, m))));
			return (1);
		}
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_hyperboloid.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

static double	get_closest_t(t_ray *ray, t_hyperboloid *hp, double t1,
		double t2)
{
	double	m1;
	double	m2;
	double	closest_t;
	double	z_limit;

	closest_t = -1.0;
	z_limit = hp->height / 2.0;
	if (t1 > EPSILON)
	{
		m1 = vec3_dot(vec3_sub(ray_at(*ray, t1), hp->position), hp->axis);
		if (fabs(m1) <= z_limit)
			closest_t = t1;
	}
	if (t2 > EPSILON && (closest_t < 0 || t2 < closest_t))
	{
		m2 = vec3_dot(vec3_sub(ray_at(*ray, t2), hp->position), hp->axis);
		if (fabs(m2) <= z_limit)
			closest_t = t2;
	}
	return (closest_t);
}

static t_vec3	calculate_coeffs(t_ray *ray, t_hyperboloid *hp, t_vec3 oc)
{
	t_vec3	coeffs;
	t_vec3	u_v;
	t_vec3	w_v;

	if (fabs(hp->axis.x) > 0.9)
		u_v = vec3_init(0, 1, 0);
	else
		u_v = vec3_init(1, 0, 0);
	u_v = vec3_normalize(vec3_cross(u_v, hp->axis));
	w_v = vec3_normalize(vec3_cross(hp->axis, u_v));
	coeffs.x = (vec3_dot(ray->direction, u_v) * vec3_dot(ray->direction, u_v))
		/ (hp->radius_a * hp->radius_a) + (vec3_dot(ray->direction, w_v)
			* vec3_dot(ray->direction, w_v)) / (hp->radius_b * hp->radius_b)
		- (vec3_dot(ray->direction, hp->axis) * vec3_dot(ray->direction,
				hp->axis));
	coeffs.y = 2.0 * ((vec3_dot(ray->direction, u_v) * vec3_dot(oc, u_v))
			/ (hp->radius_a * hp->radius_a) + (vec3_dot(ray->direction, w_v)
				* vec3_dot(oc, w_v)) / (hp->radius_b * hp->radius_b)
			- (vec3_dot(ray->direction, hp->axis) * vec3_dot(oc, hp->axis)));
	coeffs.z = (vec3_dot(oc, u_v) * vec3_dot(oc, u_v)) / (hp->radius_a
			* hp->radius_a) + (vec3_dot(oc, w_v) * vec3_dot(oc, w_v))
		/ (hp->radius_b * hp->radius_b) - (vec3_dot(oc, hp->axis) * vec3_dot(oc,
				hp->axis));
	return (coeffs);
}

static void	update_normal(t_ray *ray, t_hyperboloid *hp, t_hit_record *rec)
{
	t_vec3	point_relative;
	t_vec3	u_v;
	t_vec3	w_v;

	point_relative = vec3_sub(rec->point, hp->position);
	if (fabs(hp->axis.x) > 0.9)
		u_v = vec3_init(0, 1, 0);
	else
		u_v = vec3_init(1, 0, 0);
	u_v = vec3_normalize(vec3_cross(u_v, hp->axis));
	w_v = vec3_normalize(vec3_cross(hp->axis, u_v));
	rec->normal = vec3_normalize(vec3_add(vec3_add(vec3_mul(u_v, (2.0
							* vec3_dot(point_relative, u_v)) / (hp->radius_a
							* hp->radius_a)), vec3_mul(w_v, (2.0
							* vec3_dot(point_relative, w_v)) / (hp->radius_b
							* hp->radius_b))), vec3_mul(hp->axis, -2.0
					* vec3_dot(point_relative, hp->axis))));
	if (vec3_dot(rec->normal, ray->direction) > 0)
		rec->normal = vec3_mul(rec->normal, -1);
}

int	intersect_hyperboloid(t_ray *ray, t_hyperboloid *hp, t_hit_record *rec)
{
	t_vec3	oc;
	t_vec3	coeffs;
	double	discriminant;
	double	t;

	oc = vec3_sub(ray->origin, hp->position);
	coeffs = calculate_coeffs(ray, hp, oc);
	discriminant = coeffs.y * coeffs.y - 4.0 * coeffs.x * coeffs.z;
	if (discriminant < 0.0)
		return (0);
	t = get_closest_t(ray, hp, (-coeffs.y - sqrt(discriminant)) / (2.0
				* coeffs.x), (-coeffs.y + sqrt(discriminant)) / (2.0
				* coeffs.x));
	if (t < 0)
		return (0);
	rec->t = t;
	rec->point = ray_at(*ray, rec->t);
	update_normal(ray, hp, rec);
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_paraboloid.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

static t_vec3	calculate_abc(t_ray *ray, t_parab *pb, t_vec3 oc,
		t_vec3 axis_norm)
{
	t_vec3	coeffs;
	t_vec3	d_perp;
	t_vec3	oc_perp;
	double	axis_dot_d;
	double	axis_dot_oc;

	axis_dot_d = vec3_dot(ray->direction, axis_norm);
	axis_dot_oc = vec3_dot(oc, axis_norm);
	d_perp = vec3_sub(ray->direction, vec3_mul(axis_norm, axis_dot_d));
	oc_perp = vec3_sub(oc, vec3_mul(axis_norm, axis_dot_oc));
	coeffs.x = vec3_dot(d_perp, d_perp);
	coeffs.y = 2.0 * vec3_dot(d_perp, oc_perp) - 4.0 * pb->focal_lenght
		* axis_dot_d;
	coeffs.z = vec3_dot(oc_perp, oc_perp) - 4.0 * pb->focal_lenght
		* axis_dot_oc;
	return (coeffs);
}

static double	solve_quadratic(t_vec3 coeffs, t_ray *ray, t_parab *pb,
		t_vec3 axis_norm)
{
	double	discriminant;
	double	t1;
	double	t2;
	double	height;

	discriminant = (coeffs.y * coeffs.y) - (4.0 * coeffs.x * coeffs.z);
	if (discriminant < EPSILON)
		return (-1.0);
	t1 = (-coeffs.y - sqrt(discriminant)) / (2.0 * coeffs.x);
	t2 = (-coeffs.y + sqrt(discriminant)) / (2.0 * coeffs.x);
	if (t1 > EPSILON)
	{
		height = (vec3_dot(ray->direction, axis_norm) * t1
				+ vec3_dot(vec3_sub(ray->origin, pb->position), axis_norm));
		if (height >= 0.0 && height <= pb->height)
			return (t1);
	}
	if (t2 > EPSILON)
	{
		height = (vec3_dot(ray->direction, axis_norm) * t2
				+ vec3_dot(vec3_sub(ray->origin, pb->position), axis_norm));
		if (height >= 0.0 && height <= pb->height)
			return (t2);
	}
	return (-1.0);
}

static void	update_paraboloid_normal(t_ray *ray, t_parab *pb, t_hit_record *rec,
		t_vec3 axis_norm)
{
	t_vec3	hit_point_local;
	t_vec3	normal_unnorm;
	double	proj_hit_local;

	hit_point_local = vec3_sub(rec->point, pb->position);
	proj_hit_local = vec3_dot(hit_point_local, axis_norm);
	normal_unnorm = vec3_sub(vec3_sub(hit_point_local, vec3_mul(axis_norm,
					proj_hit_local)), vec3_mul(axis_norm, 2.0
				* pb->focal_lenght));
	rec->normal = vec3_normalize(normal_unnorm);
	if (vec3_dot(rec->normal, ray->direction) > 0)
		rec->normal = vec3_mul(rec->normal, -1.0);
}

int	intersect_paraboloid(t_ray *ray, t_parab *pb, t_hit_record *rec)
{
	t_vec3	oc;
	t_vec3	coeffs;
	double	t_final;
	t_vec3	axis_norm;

	oc = vec3_sub(ray->origin, pb->position);
	axis_norm = vec3_normalize(pb->axis);
	coeffs = calculate_abc(ray, pb, oc, axis_norm);
	t_final = solve_quadratic(coeffs, ray, pb, axis_norm);
	if (t_final < 0)
		return (0);
	rec->t = t_final;
	rec->point = ray_at(*ray, rec->t);
	update_paraboloid_normal(ray, pb, rec, axis_norm);
	return (1);
}

// // src/intersect/ft_paraboloid_utils.c
// static void	calculate_abc(t_ray *ray, t_parab *pb, t_vec3 oc, double *a,
// 		double *b, double *c)
// {
// 	t_vec3	axis_norm;
// 	t_vec3	d_perp;
// 	t_vec3	oc_perp;

// 	axis_norm = vec3_normalize(pb->axis);
// 	d_perp = vec3_sub(ray->direction, vec3_mul(axis_norm,
// 				vec3_dot(ray->direction, axis_norm)));
// 	oc_perp = vec3_sub(oc, vec3_mul(axis_norm, vec3_dot(oc, axis_norm)));
// 	*a = vec3_dot(d_perp, d_perp);
// 	*b = 2.0 * vec3_dot(d_perp, oc_perp) - 4.0 * pb->focal_lenght
// 		* vec3_dot(ray->direction, axis_norm);
// 	*c = vec3_dot(oc_perp, oc_perp) - 4.0 * pb->focal_lenght * vec3_dot(oc,
// 			axis_norm);
// }

// static double	solve_quadratic(double a, double b, double c, t_ray *ray,
// 		t_parab *pb)
// {
// 	double	discriminant;
// 	double	height;

// 	discriminant = b * b - 4 * a * c;
// 	if (discriminant < EPSILON)
// 		return (-1.0);
// 	if ((-b - sqrt(discriminant)) / (2.0 * a) > EPSILON)
// 	{
// 		height = vec3_dot(ray->direction, vec3_normalize(pb->axis)) * (-b
// 				- sqrt(discriminant)) / (2.0 * a)
// 			+ vec3_dot(vec3_sub(ray->origin, pb->position),
// 				vec3_normalize(pb->axis));
// 		if (height >= 0.0 && height <= pb->height)
// 			return (-b - sqrt(discriminant)) / (2.0 * a);
// 	}
// 	if ((-b - sqrt(discriminant)) / (2.0 * a) > EPSILON)
// 	{
// 		height = vec3_dot(ray->direction, vec3_normalize(pb->axis)) * (-b
// 				- sqrt(discriminant)) / (2.0 * a)
// 			+ vec3_dot(vec3_sub(ray->origin, pb->position),
// 				vec3_normalize(pb->axis));
// 		if (height >= 0.0 && height <= pb->height)
// 			return (-b - sqrt(discriminant)) / (2.0 * a);
// 	}
// 	return (-1.0);
// }

// static void	update_paraboloid_normal(t_ray *ray, t_parab *pb,
// t_hit_record *rec)
// {
// 	t_vec3	hit_point_local;
// 	t_vec3	normal_unnorm;
// 	t_vec3	axis_norm;

// 	hit_point_local = vec3_sub(rec->point, pb->position);
// 	axis_norm = vec3_normalize(pb->axis);
// 	normal_unnorm = vec3_sub(vec3_sub(hit_point_local, vec3_mul(axis_norm,
// 					vec3_dot(hit_point_local, axis_norm))), vec3_mul(axis_norm,
// 				2.0 * pb->focal_lenght));
// 	rec->normal = vec3_normalize(normal_unnorm);
// 	if (vec3_dot(rec->normal, ray->direction) > 0)
// 		rec->normal = vec3_mul(rec->normal, -1.0);
// }

// int	intersect_paraboloid(t_ray *ray, t_parab *pb, t_hit_record *rec)
// {
// 	t_vec3	oc;
// 	double	t_final;
// 	double	a;
// 	double	c;
// 	double	b;

// 	oc = vec3_sub(ray->origin, pb->position);
// 	calculate_abc(ray, pb, oc, &a, &b, &c);
// 	t_final = solve_quadratic(a, b, c, ray, pb);
// 	if (t_final < 0)
// 		return (0);
// 	rec->t = t_final;
// 	rec->point = ray_at(*ray, rec->t);
// 	update_paraboloid_normal(ray, pb, rec);
// 	return (1);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_plane.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minirt.h"

// src/intersect/ft_plane.c
int	intersect_plane(t_ray *ray, t_plane *pl, t_hit_record *rec)
{
	double	denominator;
	double	t;

	denominator = vec3_dot(pl->normal, ray->direction);
	if (fabs(denominator) < EPSILON)
		return (0);
	t = vec3_dot(vec3_sub(pl->position, ray->origin), pl->normal) / denominator;
	if (t < EPSILON)
		return (0);
	rec->t = t;
	rec->point = ray_at(*ray, rec->t);
	if (vec3_dot(pl->normal, ray->direction) > 0)
		rec->normal = vec3_mul(pl->normal, -1.0);
	else
		rec->normal = pl->normal;
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_sphere.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minirt.h"

// src/intersect/ft_sphere.c
static double	get_discriminant(t_ray *ray, t_vec3 oc, double radius)
{
	double	b;
	double	c;
	double	discriminant;

	b = 2.0 * vec3_dot(oc, ray->direction);
	c = vec3_dot(oc, oc) - radius * radius;
	discriminant = b * b - 4 * vec3_dot(ray->direction, ray->direction) * c;
	if (discriminant < 0)
		return (-1.0);
	return (discriminant);
}

static double	get_t_value(t_ray *ray, t_vec3 oc, double disc)
{
	double	t;
	double	a;
	double	b;

	a = vec3_dot(ray->direction, ray->direction);
	b = 2.0 * vec3_dot(oc, ray->direction);
	t = (-b - sqrt(disc)) / (2.0 * a);
	if (t < EPSILON)
	{
		t = (-b + sqrt(disc)) / (2.0 * a);
		if (t < EPSILON)
			return (-1.0);
	}
	return (t);
}

static void	update_hit_record(t_ray *ray, t_sphere *sp, t_hit_record *rec,
		double t)
{
	t_vec3	point;
	t_vec3	normal;

	rec->t = t;
	point = ray_at(*ray, rec->t);
	rec->point = point;
	normal = vec3_normalize(vec3_sub(point, sp->center));
	if (vec3_dot(ray->direction, normal) > 0)
		rec->normal = vec3_mul(normal, -1.0);
	else
		rec->normal = normal;
}

int	intersect_sphere(t_ray *ray, t_sphere *sp, t_hit_record *rec)
{
	t_vec3	oc;
	double	discriminant;
	double	t;

	oc = vec3_sub(ray->origin, sp->center);
	discriminant = get_discriminant(ray, oc, sp->radius);
	if (discriminant < 0)
		return (0);
	t = get_t_value(ray, oc, discriminant);
	if (t < 0)
		return (0);
	update_hit_record(ray, sp, rec, t);
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_light.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

t_color	calculate_reflection(t_hit_record *rec, t_scene *scene, t_ray *ray,
		int depth)
{
	t_ray			reflected_ray;
	t_hit_record	reflected_rec;
	t_vec3			effective_normal;
	t_color			reflected_color;

	if (!rec->object->material || rec->object->material->mirror_ratio <= 0.0
		|| depth >= MAX_RECURSION_DEPTH)
		return (vec3_init(0, 0, 0));
	effective_normal = get_effective_normal(rec);
	reflected_ray.origin = vec3_add(rec->point, vec3_mul(effective_normal,
				EPSILON));
	reflected_ray.direction = vec3_reflect(ray->direction, effective_normal);
	reflected_rec = find_closest_hit(&reflected_ray, scene);
	if (reflected_rec.object != NULL)
		reflected_color = calculate_light(&reflected_rec, scene, &reflected_ray,
				depth + 1);
	else
		reflected_color = scene->background_color;
	return (vec3_mul(reflected_color, rec->object->material->mirror_ratio));
}

t_color	calculate_diffuse_light(t_hit_record *rec, t_light *light,
		t_vec3 effective_normal, t_vec3 to_light)
{
	double	dot_prod;
	t_color	diffuse_color;
	t_color	object_color;

	dot_prod = vec3_dot(effective_normal, to_light);
	if (dot_prod > 0)
	{
		object_color = get_object_color(rec);
		diffuse_color = vec3_mult_vec(light->color, object_color);
		return (vec3_mul(diffuse_color, dot_prod * light->brightness));
	}
	return (vec3_init(0, 0, 0));
}

int	is_in_shadow(t_ray *ray, t_scene *scene, t_light *light)
{
	t_hit_record	current_hit;
	double			light_dist;
	t_vec3			shadow_ray_origin;
	t_ray			shadow_ray;

	shadow_ray_origin = vec3_add(ray->origin, vec3_mul(ray->direction,
				EPSILON));
	light_dist = vec3_length(vec3_sub(light->position, shadow_ray_origin));
	shadow_ray.origin = shadow_ray_origin;
	shadow_ray.direction = vec3_normalize(vec3_sub(light->position,
				shadow_ray_origin));
	current_hit = find_closest_hit(&shadow_ray, scene);
	if (current_hit.object != NULL && current_hit.t > EPSILON
		&& current_hit.t < light_dist)
		return (1);
	return (0);
}

void	get_object_intersection(t_object *obj, t_ray *ray, t_hit_record *rec)
{
	rec->t = -1.0;
	if (obj->type == SPHERE)
		intersect_sphere(ray, (t_sphere *)obj->data, rec);
	else if (obj->type == PLANE)
		intersect_plane(ray, (t_plane *)obj->data, rec);
	else if (obj->type == CYLINDER)
		intersect_cylinder(ray, (t_cylinder *)obj->data, rec);
	else if (obj->type == CONE)
		intersect_cone(ray, (t_cone *)obj->data, rec);
	else if (obj->type == HYPERBOLOID)
		intersect_hyperboloid(ray, (t_hyperboloid *)obj->data, rec);
	else if (obj->type == PARABOLOID)
		intersect_paraboloid(ray, (t_parab *)obj->data, rec);
}

t_color	calculate_light(t_hit_record *rec, t_scene *scene, t_ray *ray,
		int depth)
{
	t_color	final_color;
	t_vec3	effective_normal;
	t_color	reflected_color;

	if (rec->object == NULL)
		return (scene->background_color);
	effective_normal = get_effective_normal(rec);
	final_color = calculate_ambient_light(rec, scene);
	final_color = vec3_add(final_color, calculate_direct_lighting(rec, scene,
				ray, effective_normal));
	if (rec->object->material && rec->object->material->mirror_ratio > 0.0
		&& depth < MAX_RECURSION_DEPTH)
	{
		reflected_color = calculate_reflection(rec, scene, ray, depth);
		final_color = vec3_add(vec3_mul(final_color, 1.0
					- rec->object->material->mirror_ratio), reflected_color);
	}
	return (clamp_color(final_color));
}

// // src/render/ft_light.c
// t_color	calculate_light(t_hit_record *rec, t_scene *scene, t_ray *ray,
// 		int depth)
// {
// 	t_color			final_color;
// 	t_color			ambient_color;
// 	t_light			**lights;
// 	int				i;
// 	t_vec3			effective_normal;
// 	t_color			object_color;
// 	t_vec3			to_light;
// 	t_ray			shadow_ray;
// 	double			dot_prod;
// 	t_color			diffuse_contribution;
// 	t_color			specular_color;
// 	t_ray			reflected_ray;
// 	t_hit_record	reflected_rec;
// 	t_color			reflected_color;

// 	lights = (t_light **)scene->lights;
// 	i = 0;
// 	if (rec->object == NULL)
// 		return (scene->background_color);
// 	if (rec->object->material && rec->object->material->has_normal_map)
// 		effective_normal = get_normal_from_map(rec, rec->normal);
// 	else
// 		effective_normal = rec->normal;
// 	object_color = get_object_color(rec);
// 	ambient_color = vec3_mult_vec(scene->ambient.color, object_color);
// 	ambient_color = vec3_mul(ambient_color, scene->ambient.ratio);
// 	final_color = ambient_color;
// 	while (lights[i] != NULL)
// 	{
// 		to_light = vec3_normalize(vec3_sub(lights[i]->position, rec->point));
// 		shadow_ray.origin = vec3_add(rec->point, vec3_mul(effective_normal,
// 					EPSILON));
// 		shadow_ray.direction = to_light;
// 		if (is_in_shadow(&shadow_ray, scene, lights[i]))
// 		{
// 			i++;
// 			continue ;
// 		}
// 		dot_prod = vec3_dot(effective_normal, to_light);
// 		if (dot_prod > 0)
// 		{
// 			diffuse_contribution = vec3_mult_vec(lights[i]->color,
// 					object_color);
// 			diffuse_contribution = vec3_mul(diffuse_contribution, dot_prod
// 					* lights[i]->brightness);
// 			final_color = vec3_add(final_color, diffuse_contribution);
// 		}
// 		if (rec->object->material
// 			&& rec->object->material->specular.intensity > 0.0)
// 		{
// 			specular_color = calculate_specular_light(rec, lights[i], ray);
// 			final_color = vec3_add(final_color, specular_color);
// 		}
// 		i++;
// 	}
// 	if (rec->object->material && rec->object->material->mirror_ratio > 0.0
// 		&& depth < MAX_RECURSION_DEPTH)
// 	{
// 		reflected_ray.origin = vec3_add(rec->point, vec3_mul(effective_normal,
// 					EPSILON));
// 		reflected_ray.direction = vec3_reflect(ray->direction,
// 				effective_normal);
// 		reflected_rec = find_closest_hit(&reflected_ray, scene);
// 		if (reflected_rec.object != NULL)
// 			reflected_color = calculate_light(&reflected_rec, scene,
// 					&reflected_ray, depth + 1);
// 		else
// 			reflected_color = scene->background_color;
// 		final_color = vec3_add(vec3_mul(final_color, 1.0
// 					- rec->object->material->mirror_ratio),
// 				vec3_mul(reflected_color, rec->object->material->mirror_ratio));
// 	}
// 	final_color.x = fmin(1.0, fmax(0.0, final_color.x));
// 	final_color.y = fmin(1.0, fmax(0.0, final_color.y));
// 	final_color.z = fmin(1.0, fmax(0.0, final_color.z));
// 	return (final_color);
// }

// // src/render/ft_light.c
// int	is_in_shadow(t_ray *shadow_ray, t_scene *scene, t_light *light)
// {
// 	t_hit_record	current_hit;
// 	t_object		**objects;
// 	double			light_dist;
// 	int				i;

// 	objects = (t_object **)scene->objects;
// 	i = 0;
// 	light_dist = vec3_length(vec3_sub(light->position, shadow_ray->origin));
// 	while (objects[i] != NULL)
// 	{
// 		current_hit.t = -1.0;
// 		if (objects[i]->type == SPHERE)
// 			intersect_sphere(shadow_ray, (t_sphere *)objects[i]->data,
// 				&current_hit);
// 		else if (objects[i]->type == PLANE)
// 			intersect_plane(shadow_ray, (t_plane *)objects[i]->data,
// 				&current_hit);
// 		else if (objects[i]->type == CYLINDER)
// 			intersect_cylinder(shadow_ray, (t_cylinder *)objects[i]->data,
// 				&current_hit);
// 		else if (objects[i]->type == CONE)
// 			intersect_cone(shadow_ray, (t_cone *)objects[i]->data,
// 				&current_hit);
// 		else if (objects[i]->type == HYPERBOLOID)
// 			intersect_hyperboloid(shadow_ray, (t_hyperboloid *)objects[i]->data,
// 				&current_hit);
// 		else if (objects[i]->type == PARABOLOID)
// 			intersect_paraboloid(shadow_ray, (t_parab *)objects[i]->data,
// 				&current_hit);
// 		if (current_hit.t > EPSILON && current_hit.t < light_dist)
// 			return (1);
// 		i++;
// 	}
// 	return (0);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_light.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

// Calculates the ambient light contribution
t_color	calculate_ambient_light(t_hit_record *rec, t_scene *scene)
{
	t_color	object_color;
	t_color	ambient_color;

	object_color = get_object_color(rec);
	ambient_color = vec3_mult_vec(scene->ambient.color, object_color);
	return (vec3_mul(ambient_color, scene->ambient.ratio));
}

// Clamps a color's components to the range [0.0, 1.0]
t_color	clamp_color(t_color color)
{
	color.x = fmin(1.0, fmax(0.0, color.x));
	color.y = fmin(1.0, fmax(0.0, color.y));
	color.z = fmin(1.0, fmax(0.0, color.z));
	return (color);
}

// Determines the effective normal (either from a normal map or the hit record)
t_vec3	get_effective_normal(t_hit_record *rec)
{
	if (rec->object->material && rec->object->material->has_normal_map)
		return (get_normal_from_map(rec, rec->normal));
	return (rec->normal);
}

// Calculates the combined diffuse and specular contribution from a single light
t_color	get_light_contribution(t_light_context *ctx, t_light *light)
{
	t_ray	shadow_ray;
	t_color	contribution;

	shadow_ray.origin = vec3_add(ctx->rec->point,
			vec3_mul(ctx->effective_normal, EPSILON));
	shadow_ray.direction = vec3_normalize(vec3_sub(light->position,
				ctx->rec->point));
	if (is_in_shadow(&shadow_ray, ctx->scene, light))
		return (vec3_init(0, 0, 0));
	contribution = calculate_diffuse_light(ctx->rec, light,
			ctx->effective_normal, shadow_ray.direction);
	if (ctx->rec->object->material
		&& ctx->rec->object->material->specular.intensity > 0.0)
		contribution = vec3_add(contribution, calculate_specular_light(ctx->rec,
					light, ctx->ray));
	return (contribution);
}

// Calculates the total direct lighting by iterating over all lights
t_color	calculate_direct_lighting(t_hit_record *rec, t_scene *scene, t_ray *ray,
		t_vec3 effective_normal)
{
	t_color			total_light;
	t_light			**lights;
	t_light_context	ctx;
	int				i;

	total_light = vec3_init(0, 0, 0);
	lights = (t_light **)scene->lights;
	i = 0;
	ctx.rec = rec;
	ctx.scene = scene;
	ctx.ray = ray;
	ctx.effective_normal = effective_normal;
	while (lights[i] != NULL)
	{
		total_light = vec3_add(total_light, get_light_contribution(&ctx,
					lights[i]));
		i++;
	}
	return (total_light);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_specular_light.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minirt.h"

// src/render/ft_specular.c
double	get_specular_factor(t_hit_record *rec, t_light *light, t_ray *ray)
{
	t_vec3	effective_normal;
	t_vec3	to_light;
	t_vec3	view_dir;
	t_vec3	reflect_dir;

	if (rec->object->material && rec->object->material->has_normal_map)
		effective_normal = get_normal_from_map(rec, rec->normal);
	else
		effective_normal = rec->normal;
	to_light = vec3_normalize(vec3_sub(light->position, rec->point));
	view_dir = vec3_normalize(vec3_mul(ray->direction, -1.0));
	reflect_dir = vec3_reflect(vec3_mul(to_light, -1.0), effective_normal);
	return (vec3_dot(view_dir, reflect_dir));
}

// src/render/ft_specular.c
t_color	calculate_specular_light(t_hit_record *rec, t_light *light, t_ray *ray)
{
	double	spec_factor;
	double	diff;
	t_vec3	effective_normal;
	t_vec3	to_light;

	spec_factor = get_specular_factor(rec, light, ray);
	if (spec_factor > 0 && rec->object->material->specular.shininess > 0)
	{
		spec_factor = pow(spec_factor,
				rec->object->material->specular.shininess);
		if (rec->object->material && rec->object->material->has_normal_map)
			effective_normal = get_normal_from_map(rec, rec->normal);
		else
			effective_normal = rec->normal;
		to_light = vec3_normalize(vec3_sub(light->position, rec->point));
		diff = vec3_dot(effective_normal, to_light);
		if (diff > 0)
		{
			return (vec3_mul(light->color,
					rec->object->material->specular.intensity * spec_factor
					* diff * light->brightness));
		}
	}
	return (vec3_init(0, 0, 0));
}

// src/render/ft_specular_light.c
// t_color	calculate_specular_light(t_hit_record *rec, t_light *light,
// t_ray *ray)
// {
// 	t_vec3	to_light;
// 	t_vec3	view_dir;
// 	t_vec3	reflect_dir;
// 	double	spec_factor;
// 	t_color	specular_color;
// 	t_vec3	effective_normal;
// 	double	diff;

// 	if (rec->object->material && rec->object->material->has_normal_map)
// 		effective_normal = get_normal_from_map(rec, rec->normal);
// 	else
// 		effective_normal = rec->normal;
// 	to_light = vec3_normalize(vec3_sub(light->position, rec->point));
// 	view_dir = vec3_normalize(vec3_mul(ray->direction, -1.0));
// 	reflect_dir = vec3_reflect(vec3_mul(to_light, -1.0), effective_normal);
// 	spec_factor = vec3_dot(view_dir, reflect_dir);
// 	if (spec_factor > 0 && rec->object->material->specular.shininess > 0)
// 	{
// 		spec_factor = pow(spec_factor,
// 				rec->object->material->specular.shininess);
// 		diff = vec3_dot(effective_normal, to_light);
// 		if (diff > 0)
// 		{
// 			specular_color = vec3_mul(light->color,
// 					rec->object->material->specular.intensity * spec_factor
// 					* diff * light->brightness);
// 			return (specular_color);
// 		}
// 	}
// 	return (vec3_init(0, 0, 0));
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_texture.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

t_vec2	get_texture_uv(t_hit_record *rec)
{
	if (rec->object->type == SPHERE)
		return (get_uv_sphere(rec));
	else if (rec->object->type == PLANE)
		return (get_uv_plane(rec));
	else if (rec->object->type == CYLINDER)
		return (get_uv_cylinder(rec));
	else if (rec->object->type == CONE)
		return (get_uv_cone(rec));
	else if (rec->object->type == HYPERBOLOID)
		return (get_uv_hyperboloid(rec));
	else if (rec->object->type == PARABOLOID)
		return (get_uv_paraboloid(rec));
	return ((t_vec2){0.0, 0.0});
}

// src/render/ft_texture.c
t_color	get_texture_color(t_hit_record *rec)
{
	t_vec2			uv;
	mlx_texture_t	*texture;
	int				index;
	t_color			tex_color;

	if (!rec->object->material || !rec->object->material->has_texture)
		return (rec->object->color);
	texture = rec->object->material->color_img;
	if (texture->width <= 0 || texture->height <= 0)
		return (rec->object->color);
	uv = get_texture_uv(rec);
	uv.x = fmax(0.0, fmin(1.0, uv.x));
	uv.y = fmax(0.0, fmin(1.0, uv.y));
	index = ((int)(uv.y * texture->height - 1) * texture->width + (int)(uv.x
				* (texture->width - 1))) * 4;
	tex_color.x = (double)texture->pixels[index] / 255.0;
	tex_color.y = (double)texture->pixels[index + 1] / 255.0;
	tex_color.z = (double)texture->pixels[index + 2] / 255.0;
	return (tex_color);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_uv_mapping.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

// src/assets/ft_uv_mapping.c
t_vec2	get_uv_cone(t_hit_record *rec)
{
	t_cone	*cn;
	t_vec3	local_point;
	t_vec3	temp_axis;
	t_vec3	p;
	double	u;

	cn = (t_cone *)rec->object->data;
	local_point = vec3_sub(rec->point, cn->position);
	temp_axis = vec3_normalize(vec3_cross(cn->axis, vec3_init(1, 0, 0)));
	if (vec3_length(temp_axis) < EPSILON)
		temp_axis = vec3_normalize(vec3_cross(cn->axis, vec3_init(0, 1, 0)));
	p = vec3_sub(local_point, vec3_mul(cn->axis, vec3_dot(local_point,
					cn->axis)));
	u = acos(vec3_dot(p, temp_axis) / vec3_length(p)) / (2.0 * M_PI);
	if (vec3_dot(vec3_cross(temp_axis, p), cn->axis) < 0)
		u = 1.0 - u;
	return (vec2_init(u, vec3_dot(local_point, cn->axis) / cn->height));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_uv_mapping.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

// src/assets/ft_uv_mapping.c
t_vec2	get_uv_cylinder(t_hit_record *rec)
{
	t_cylinder	*cy;
	t_vec3		local_point;
	t_vec3		temp_axis;
	t_vec3		p;
	double		u;

	cy = (t_cylinder *)rec->object->data;
	local_point = vec3_sub(rec->point, cy->position);
	temp_axis = vec3_normalize(vec3_cross(cy->axis, vec3_init(1, 0, 0)));
	if (vec3_length(temp_axis) < EPSILON)
		temp_axis = vec3_normalize(vec3_cross(cy->axis, vec3_init(0, 1, 0)));
	p = vec3_sub(local_point, vec3_mul(cy->axis, vec3_dot(local_point,
					cy->axis)));
	u = acos(vec3_dot(p, temp_axis) / vec3_length(p)) / (2.0 * M_PI);
	if (vec3_dot(vec3_cross(temp_axis, p), cy->axis) < 0)
		u = 1.0 - u;
	return (vec2_init(u, (vec3_dot(local_point, cy->axis) + cy->height / 2.0)
			/ cy->height));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_uv_mapping.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

// src/assets/ft_uv_mapping.c
t_vec2	get_uv_hyperboloid(t_hit_record *rec)
{
	t_hyperboloid	*hp;
	t_vec3			local_point;
	t_vec3			temp_axis;
	t_vec3			p;

	hp = (t_hyperboloid *)rec->object->data;
	local_point = vec3_sub(rec->point, hp->position);
	temp_axis = vec3_normalize(vec3_cross(hp->axis, vec3_init(0, 0, 1)));
	if (vec3_length(temp_axis) < EPSILON)
		temp_axis = vec3_normalize(vec3_cross(hp->axis, vec3_init(0, 1, 0)));
	p = vec3_sub(local_point, vec3_mul(hp->axis, vec3_dot(local_point,
					hp->axis)));
	return (vec2_init(atan2(vec3_dot(p, vec3_cross(hp->axis, temp_axis)),
				vec3_dot(p, temp_axis)) / (2.0 * M_PI) + 0.5,
			(vec3_dot(local_point, hp->axis) + hp->height / 2.0) / hp->height));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_uv_mapping.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

// src/assets/ft_uv_mapping.c
t_vec3	get_paraboloid_temp_axis(t_vec3 axis)
{
	t_vec3	temp_axis;

	temp_axis = vec3_normalize(vec3_cross(axis, vec3_init(1, 0, 0)));
	if (vec3_length(temp_axis) < EPSILON)
		temp_axis = vec3_normalize(vec3_cross(axis, vec3_init(0, 1, 0)));
	return (temp_axis);
}

double	calculate_u_coord(t_vec3 local_point, t_parab *pb)
{
	t_vec3	temp_axis;
	t_vec3	p;
	double	u;

	temp_axis = get_paraboloid_temp_axis(pb->axis);
	p = vec3_sub(local_point, vec3_mul(pb->axis, vec3_dot(local_point,
					pb->axis)));
	u = acos(vec3_dot(p, temp_axis) / vec3_length(p)) / (2.0 * M_PI);
	if (vec3_dot(vec3_cross(temp_axis, p), pb->axis) < 0)
		u = 1.0 - u;
	return (u);
}

t_vec2	get_uv_paraboloid(t_hit_record *rec)
{
	t_parab	*pb;
	t_vec3	local_point;
	double	u;
	double	v;

	pb = (t_parab *)rec->object->data;
	local_point = vec3_sub(rec->point, pb->position);
	v = vec3_dot(local_point, pb->axis) / pb->height;
	u = calculate_u_coord(local_point, pb);
	return (vec2_init(u, v));
}

// t_vec2	get_uv_paraboloid(t_hit_record *rec)
// {
// 	t_parab	*pb;
// 	t_vec3	local_point;
// 	double	v;
// 	t_vec3	temp_axis;
// 	t_vec3	p;
// 	double	u;

// 	pb = (t_parab *)rec->object->data;
// 	local_point = vec3_sub(rec->point, pb->position);
// 	v = vec3_dot(local_point, pb->axis) / pb->height;
// 	temp_axis = vec3_normalize(vec3_cross(pb->axis, vec3_init(1, 0, 0)));
// 	if (vec3_length(temp_axis) < EPSILON)
// 		temp_axis = vec3_normalize(vec3_cross(pb->axis, vec3_init(0, 1, 0)));
// 	p = vec3_sub(local_point, vec3_mul(pb->axis, vec3_dot(local_point,
// 					pb->axis)));
// 	u = acos(vec3_dot(p, temp_axis) / vec3_length(p)) / (2.0 * M_PI);
// 	if (vec3_dot(vec3_cross(temp_axis, p), pb->axis) < 0)
// 		u = 1.0 - u;
// 	return (vec2_init(u, v));
// }/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_uv_mapping.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

// src/assets/ft_uv_mapping.c
t_vec3	*get_plane_axes(t_vec3 normal)
{
	t_vec3	*axes;
	t_vec3	local_x_axis;

	axes = malloc(sizeof(t_vec3) * 2);
	if (!axes)
		return (NULL);
	local_x_axis = vec3_normalize(vec3_cross(normal, vec3_init(0, 1, 0)));
	if (vec3_length(local_x_axis) < EPSILON)
		local_x_axis = vec3_normalize(vec3_cross(normal, vec3_init(1, 0, 0)));
	axes[0] = local_x_axis;
	axes[1] = vec3_normalize(vec3_cross(local_x_axis, normal));
	return (axes);
}

t_vec2	get_uv_plane(t_hit_record *rec)
{
	t_plane	*pl;
	t_vec3	local_point;
	t_vec3	*axes;
	t_vec2	uv;

	pl = (t_plane *)rec->object->data;
	axes = get_plane_axes(pl->normal);
	if (!axes)
		return ((t_vec2){0.0, 0.0});
	local_point = vec3_sub(rec->point, pl->position);
	uv.x = vec3_dot(local_point, axes[0]) / 10.0;
	uv.y = vec3_dot(local_point, axes[1]) / 10.0;
	free(axes);
	uv.x = uv.x - floor(uv.x);
	uv.y = uv.y - floor(uv.y);
	return (uv);
}

// t_vec2	get_uv_plane(t_hit_record *rec)
// {
// 	t_plane	*pl;
// 	t_vec3	local_x_axis;
// 	t_vec3	local_y_axis;
// 	t_vec3	local_point;
// 	double	u;
// 	double	v;

// 	pl = (t_plane *)rec->object->data;
// 	local_x_axis = vec3_normalize(vec3_cross(pl->normal, vec3_init(0, 1, 0)));
// 	if (vec3_length(local_x_axis) < EPSILON)
// 		local_x_axis = vec3_normalize(vec3_cross(pl->normal, vec3_init(1, 0,
// 						0)));
// 	local_y_axis = vec3_normalize(vec3_cross(local_x_axis, pl->normal));
// 	local_point = vec3_sub(rec->point, pl->position);
// 	u = vec3_dot(local_point, local_x_axis) / 10.0;
// 	v = vec3_dot(local_point, local_y_axis) / 10.0;
// 	u = u - floor(u);
// 	v = v - floor(v);
// 	return (vec2_init(u, v));
// }/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_uv_mapping.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

// src/assets/ft_uv_mapping.c
t_vec2	get_uv_sphere(t_hit_record *rec)
{
	t_vec3	local_point;
	double	u;
	double	v;

	local_point = vec3_sub(rec->point, ((t_sphere *)rec->object->data)->center);
	u = 0.5 + atan2(local_point.z, local_point.x) / (2.0 * M_PI);
	v = 0.5 - asin(local_point.y / ((t_sphere *)rec->object->data)->radius)
		/ M_PI;
	return (vec2_init(u, v));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   render.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../include/minirt.h"

t_color	calculate_subpixel_color(t_data *data, t_subpixel_data sp)
{
	t_ray			ray;
	t_hit_record	rec;
	t_color			subpixel_color;

	ray = generate_antialiased_ray(sp, &data->scene);
	pthread_mutex_lock(&data->progress_mutex);
	data->ray_count++;
	pthread_mutex_unlock(&data->progress_mutex);
	rec = find_closest_hit(&ray, &data->scene);
	if (rec.object != NULL)
		subpixel_color = calculate_light(&rec, &data->scene, &ray, 0);
	else
		subpixel_color = data->scene.background_color;
	return (subpixel_color);
}

t_color	render_pixel(int x, int y, t_data *data)
{
	t_color			final_color;
	t_subpixel_data	sp;

	final_color = vec3_init(0.0, 0.0, 0.0);
	sp.x = x;
	sp.y = y;
	sp.sub_y = 0;
	while (sp.sub_y < SUBPIXEL_SAMPLES)
	{
		sp.sub_x = 0;
		while (sp.sub_x < SUBPIXEL_SAMPLES)
		{
			final_color = vec3_add(final_color, calculate_subpixel_color(data,
						sp));
			sp.sub_x++;
		}
		sp.sub_y++;
	}
	return (final_color);
}

void	render_row(t_data *data, int y)
{
	t_color	final_color;
	int		x;

	x = 0;
	while (x < data->scene.width)
	{
		final_color = render_pixel(x, y, data);
		final_color = vec3_mul(final_color, 1.0 / (double)(SUBPIXEL_SAMPLES
					* SUBPIXEL_SAMPLES));
		mlx_put_pixel(data->mlx.img.img_ptr, x, y, color_to_int(final_color));
		x++;
	}
}

void	*render_thread_func(void *arg)
{
	t_thread_data	*thread_data;
	t_data			*data;
	int				y;

	thread_data = (t_thread_data *)arg;
	data = thread_data->global_data;
	y = thread_data->start_row;
	while (y < thread_data->end_row)
	{
		render_row(data, y);
		pthread_mutex_lock(&data->progress_mutex);
		data->rendered_rows++;
		pthread_mutex_unlock(&data->progress_mutex);
		y++;
	}
	return (NULL);
}

// void	*render_thread_func(void *arg)
// {
// 	t_thread_data	*thread_data;
// 	t_data			*data;
// 	t_ray			ray;
// 	t_hit_record	rec;
// 	t_color			final_color;
// 	t_color			subpixel_color;
// 	double			inv_sub_sq;

// 	int y, x;
// 	int sub_x, sub_y;
// 	inv_sub_sq = 1.0 / (double)(SUBPIXEL_SAMPLES * SUBPIXEL_SAMPLES);
// 	thread_data = (t_thread_data *)arg;
// 	data = thread_data->global_data;
// 	y = thread_data->start_row;
// 	while (y < thread_data->end_row)
// 	{
// 		x = 0;
// 		while (x < data->scene.width)
// 		{
// 			final_color = vec3_init(0.0, 0.0, 0.0);
// 			sub_y = 0;
// 			while (sub_y < SUBPIXEL_SAMPLES)
// 			{
// 				sub_x = 0;
// 				while (sub_x < SUBPIXEL_SAMPLES)
// 				{
// 					ray = generate_antialiased_ray(x, y, sub_x, sub_y,
// 							&data->scene);
// 					pthread_mutex_lock(&data->progress_mutex);
// 					data->ray_count++; // Incrementar el contador
// 					pthread_mutex_unlock(&data->progress_mutex);
// 					rec = find_closest_hit(&ray, &data->scene);
// 					if (rec.object != NULL)
// 						subpixel_color = calculate_light(&rec, &data->scene,
// 								&ray, 0);
// 					else
// 						subpixel_color = data->scene.background_color;
// 					final_color = vec3_add(final_color, subpixel_color);
// 					sub_x++;
// 				}
// 				sub_y++;
// 			}
// 			final_color = vec3_mul(final_color, inv_sub_sq);
// 			mlx_put_pixel(data->mlx.img.img_ptr, x, y,
// 				color_to_int(final_color));
// 			x++;
// 		}
// 		pthread_mutex_lock(&data->progress_mutex);
// 		data->rendered_rows++;
// 		pthread_mutex_unlock(&data->progress_mutex);
// 		y++;
// 	}
// 	return (NULL);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   thread.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

void	init_thread_data(t_thread_init_data *init_data, t_data *data)
{
	init_data->td[init_data->i].id = init_data->i;
	init_data->td[init_data->i].start_row = *init_data->start_row;
	if (init_data->i == data->num_threads - 1)
		init_data->td[init_data->i].end_row = data->scene.height;
	else
		init_data->td[init_data->i].end_row = *init_data->start_row
			+ init_data->rows_per_thread;
	init_data->td[init_data->i].global_data = data;
	*init_data->start_row = init_data->td[init_data->i].end_row;
}

void	create_and_run_threads(t_data *data, pthread_t *threads,
		t_thread_data *thread_data)
{
	t_thread_init_data	init_d;
	int					rows_per_thread;
	int					start_row;

	init_d.td = thread_data;
	init_d.rows_per_thread = data->scene.height / data->num_threads;
	init_d.i = 0;
	start_row = 0;
	while (init_d.i < data->num_threads)
	{
		init_d.start_row = &start_row;
		init_thread_data(&init_d, data);
		if (pthread_create(&threads[init_d.i], NULL, render_thread_func,
				&thread_data[init_d.i]) != 0)
		{
			printf("Error\nFallo al crear el hilo %d.\n", init_d.i);
			while (--init_d.i >= 0)
				pthread_join(threads[init_d.i], NULL);
			pthread_mutex_destroy(&data->progress_mutex);
			exit(1);
		}
		init_d.i++;
	}
}

static void	manage_thread_lifecycle(t_data *data, pthread_t *threads,
		t_thread_data *thread_data)
{
	int	i;

	create_and_run_threads(data, threads, thread_data);
	i = 0;
	while (i < data->num_threads)
	{
		pthread_join(threads[i], NULL);
		i++;
	}
}

static void	display_progress(t_data *data)
{
	while (data->rendered_rows < data->scene.height)
	{
		printf("\rRenderizando: %.2f%% completado...",
			((double)data->rendered_rows / data->scene.height) * 100.0);
		fflush(stdout);
		usleep(50000);
	}
	printf("\rRenderizado: 100.00%% completado!\n");
}

void	render_threaded(t_data *data)
{
	pthread_t		*threads;
	t_thread_data	*thread_data;

	threads = (pthread_t *)malloc(sizeof(pthread_t) * data->num_threads);
	if (!threads)
		ft_error_exit("Error\nMemory allocation for threads failed.\n");
	thread_data = (t_thread_data *)malloc(sizeof(t_thread_data)
			* data->num_threads);
	if (!thread_data)
	{
		free(threads);
		ft_error_exit("Error\nMemory allocation for thread_data failed.\n");
	}
	data->rendered_rows = 0;
	data->ray_count = 0;
	manage_thread_lifecycle(data, threads, thread_data);
	display_progress(data);
	free(threads);
	free(thread_data);
}

// void	render_threaded(t_data *data)
// {
// 	pthread_t		threads[data->num_threads];
// 	t_thread_data	thread_data[data->num_threads];
// 	int				i;
// 	int				rows_per_thread;
// 	int				start_row;

// 	data->rendered_rows = 0;
// 	data->ray_count = 0;
// 	rows_per_thread = data->scene.height / data->num_threads;
// 	i = 0;
// 	start_row = 0;
// 	while (i < data->num_threads)
// 	{
// 		thread_data[i].id = i;
// 		thread_data[i].start_row = start_row;
// 		if (i == data->num_threads - 1)
// 			thread_data[i].end_row = data->scene.height;
// 		else
// 			thread_data[i].end_row = start_row + rows_per_thread;
// 		thread_data[i].global_data = data;
// 		if (pthread_create(&threads[i], NULL, render_thread_func,
// 				&thread_data[i]) != 0)
// 		{
// 			printf("Error\nFallo al crear el hilo %d.\n", i);
// 			while (--i >= 0)
// 				pthread_join(threads[i], NULL);
// 			pthread_mutex_destroy(&data->progress_mutex);
// 			exit(1);
// 		}
// 		start_row = thread_data[i].end_row;
// 		i++;
// 	}
// 	while (data->rendered_rows < data->scene.height)
// 	{
// 		printf("\rRenderizando: %.2f%% completado...",
// 			((double)data->rendered_rows / data->scene.height) * 100.0);
// 		fflush(stdout);
// 		usleep(50000);
// 	}
// 	printf("\rRenderizado: 100.00%% completado!\n");
// 	i = 0;
// 	while (i < data->num_threads)
// 	{
// 		pthread_join(threads[i], NULL);
// 		i++;
// 	}
// }

// printf("Total de rayos generados: %lu\n", data->ray_count);/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   nthreads.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minirt.h"

int	get_num_processors(void)
{
	long	num_cores;

	num_cores = sysconf(_SC_NPROCESSORS_ONLN);
	if (num_cores < 1)
		return (1);
	return ((int)num_cores);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   nthreads.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

t_vec3	ray_at(t_ray r, double t)
{
	return (vec3_add(r.origin, vec3_mul(r.direction, t)));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec2_dot.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../../include/minirt.h"

double	vec2_dot(t_vec2 v1, t_vec2 v2)
{
	return (v1.x * v2.x + v1.y * v2.y);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec2_init.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minirt.h"

t_vec2	vec2_init(double x, double y)
{
	t_vec2	vec;

	vec.x = x;
	vec.y = y;
	return (vec);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec2_length.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../../include/minirt.h"

double	vec2_length(t_vec2 v)
{
	return (ft_sqrt(vec2_dot(v, v)));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec2_normalize.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minirt.h"

t_vec2	vec2_normalize(t_vec2 v)
{
	double	length;

	length = vec2_length(v);
	if (length < EPSILON)
		return (vec2_init(0, 0));
	return (vec2_init(v.x / length, v.y / length));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_rotate_vector.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../../include/minirt.h"

// t_vec3	rotate_vector(t_vec3 v, t_vec3 axis, double angle)
// {
// 	t_vec3	result;
// 	double	c;
// 	double	s;
// 	double	t;
// 	double	x;
// 	double	y;
// 	double	z;

// 	c = cos(angle);
// 	s = sin(angle);
// 	t = 1.0 - c;
// 	axis = vec3_normalize(axis);
// 	x = axis.x;
// 	y = axis.y;
// 	z = axis.z;
// 	result.x = (t * x * x + c) * v.x + (t * x * y - s * z) * v.y + (t * x * z
// 			+ s * y) * v.z;
// 	result.y = (t * x * y + s * z) * v.x + (t * y * y + c) * v.y + (t * y * z
// 			- s * x) * v.z;
// 	result.z = (t * x * z - s * y) * v.x + (t * y * z + s * x) * v.y + (t * z
// 			* z + c) * v.z;
// 	return (result);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_add.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minirt.h"

t_vec3	vec3_add(t_vec3 v1, t_vec3 v2)
{
	return (vec3_init(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_cross.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minirt.h"

t_vec3	vec3_cross(t_vec3 v1, t_vec3 v2)
{
	t_vec3	result;

	result.x = v1.y * v2.z - v1.z * v2.y;
	result.y = v1.z * v2.x - v1.x * v2.z;
	result.z = v1.x * v2.y - v1.y * v2.x;
	return (result);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_div.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minirt.h"

t_vec3	vec3_div(t_vec3 v, double scalar)
{
	if (scalar == 0.0)
		return (vec3_init(0, 0, 0));
	return (vec3_init(v.x / scalar, v.y / scalar, v.z / scalar));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_dot.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minirt.h"

double	vec3_dot(t_vec3 v1, t_vec3 v2)
{
	return (v1.x * v2.x + v1.y * v2.y + v1.z * v2.z);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_init.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minirt.h"

t_vec3	vec3_init(double x, double y, double z)
{
	t_vec3	v;

	v.x = x;
	v.y = y;
	v.z = z;
	return (v);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_length.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minirt.h"

double	vec3_length(t_vec3 v)
{
	return (sqrt(vec3_dot(v, v)));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_length_squared.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minirt.h"

double	vec3_length_squared(t_vec3 v)
{
	return (vec3_dot(v, v));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_mul.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minirt.h"

t_vec3	vec3_mul(t_vec3 v, double scalar)
{
	return (vec3_init(v.x * scalar, v.y * scalar, v.z * scalar));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_mult_vec.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minirt.h"

t_vec3	vec3_mult_vec(t_vec3 v1, t_vec3 v2)
{
	return (vec3_init(v1.x * v2.x, v1.y * v2.y, v1.z * v2.z));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_normalize.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minirt.h"

t_vec3	vec3_normalize(t_vec3 v)
{
	double	length;

	length = vec3_length(v);
	if (length == 0.0)
		return (vec3_init(0, 0, 0));
	return (vec3_div(v, length));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_reflect.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minirt.h"

t_vec3	vec3_reflect(t_vec3 v, t_vec3 n)
{
	return (vec3_sub(v, vec3_mul(n, 2 * vec3_dot(v, n))));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_sub.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minirt.h"

t_vec3	vec3_sub(t_vec3 v1, t_vec3 v2)
{
	return (vec3_init(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   hook.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

// void	key_hook(mlx_key_data_t keydata, void *param)
// {
// 	t_data	*data;
// 	t_vec3	move_dir;

// 	data = (t_data *)param;
// 	if (keydata.key == MLX_KEY_ESCAPE && keydata.action == MLX_PRESS)
// 		mlx_close_window(data->mlx.mlx_ptr);
// 	if (keydata.key == MLX_KEY_R && keydata.action == MLX_PRESS)
// 	{
// 		printf("R\n");
// 		data->auto_rotate_active = !data->auto_rotate_active;
// 	}
// 	move_dir = vec3_init(0, 0, 0);
// 	if (keydata.action == MLX_PRESS || keydata.action == MLX_REPEAT)
// 	{
// 		if (keydata.key == MLX_KEY_W || keydata.key == MLX_KEY_UP)
// 			move_dir = vec3_add(move_dir, data->scene.camera.forward);
// 		else if (keydata.key == MLX_KEY_S || keydata.key == MLX_KEY_DOWN)
// 			move_dir = vec3_sub(move_dir, data->scene.camera.forward);
// 		if (keydata.key == MLX_KEY_A || keydata.key == MLX_KEY_LEFT)
// 			move_dir = vec3_sub(move_dir, data->scene.camera.right);
// 		else if (keydata.key == MLX_KEY_D || keydata.key == MLX_KEY_RIGHT)
// 			move_dir = vec3_add(move_dir, data->scene.camera.right);
// 		if (keydata.key == MLX_KEY_SPACE)
// 			move_dir.y += 1.0;
// 		else if (keydata.key == MLX_KEY_C)
// 			move_dir.y -= 1.0;
// 		if (vec3_length(move_dir) > 0)
// 		{
// 			data->scene.camera.position = vec3_add(data->scene.camera.position,
// 					vec3_mul(vec3_normalize(move_dir), MOVE_SPEED));
// 			render_threaded(data);
// 		}
// 	}
// }

void	key_hook(mlx_key_data_t keydata, void *param)
{
	t_data	*data;

	data = (t_data *)param;
	if (keydata.key == MLX_KEY_ESCAPE && keydata.action == MLX_PRESS)
		mlx_close_window(data->mlx.mlx_ptr);
}

// void	mouse_move_hook(double x, double y, void *param)
// {
// 	t_data	*data;
// 	double	move_distance;
// 	t_vec3	axis_x;
// 	t_vec3	axis_y;

// 	data = (t_data *)param;
// 	double dx, dy;
// 	if (data->mouse_state.is_pressed)
// 	{
// 		dx = x - data->mouse_state.last_x;
// 		dy = y - data->mouse_state.last_y;
// 		move_distance = sqrt(dx * dx + dy * dy);
// 		if (move_distance > MOUSE_MOVE_THRESHOLD)
// 		{
// 			axis_x = vec3_init(0, 1, 0);
// 			axis_y = vec3_init(1, 0, 0);
// 			data->scene.camera.orientation = rotate_vector(
//                  data->scene.camera.orientation, axis_x, dx * 0.01);
// 			data->scene.camera.orientation = rotate_vector(
//                  data->scene.camera.orientation, axis_y, dy * 0.01);
// 			data->scene.camera.forward = vec3_normalize(
//                  data->scene.camera.orientation);
// 			data->scene.camera.right = vec3_normalize(
//                      vec3_cross(data->scene.camera.forward,
//                      (t_vec3){0, 1, 0}));
// 			data->scene.camera.up = vec3_normalize(vec3_cross(
//                      data->scene.camera.right,
// 						data->scene.camera.forward));
// 			render_threaded(data);
// 		}
// 	}
// 	data->mouse_state.last_x = x;
// 	data->mouse_state.last_y = y;
// }

// void	mouse_press_hook(mouse_key_t button, action_t action,
// 		modifier_key_t modifier, void *param)
// {
// 	t_data	*data;

// 	data = (t_data *)param;
// 	(void)modifier;
// 	if (button == MLX_MOUSE_BUTTON_LEFT)
// 	{
// 		if (action == MLX_PRESS)
// 			data->mouse_state.is_pressed = true;
// 		else
// 			data->mouse_state.is_pressed = false;
// 	}
// }

// void	scroll_hook(double xdelta, double ydelta, void *param)
// {
// 	t_data			*data;
// 	double			zoom_factor;
// 	t_ray			temp_ray;
// 	t_hit_record	rec;
// 	t_vec3			target_point;

// 	data = (t_data *)param;
// 	int32_t mouse_x, mouse_y;
// 	zoom_factor = 0.1;
// 	mlx_get_mouse_pos(data->mlx.mlx_ptr, &mouse_x, &mouse_y);
// 	temp_ray = generate_antialiased_ray((int)mouse_x, (int)mouse_y, 0, 0,
// 			&data->scene);
// 	rec = find_closest_hit(&temp_ray, &data->scene);
// 	if (rec.object != NULL)
// 		target_point = ray_at(temp_ray, rec.t);
// 	else
// 		target_point = ray_at(temp_ray, 10.0);
// 	if (ydelta > 0)
// 		data->scene.camera.position = vec3_add(data->scene.camera.position,
// 				vec3_mul(vec3_sub(target_point, data->scene.camera.position),
// 					zoom_factor));
// 	else if (ydelta < 0)
// 		data->scene.camera.position = vec3_sub(data->scene.camera.position,
// 				vec3_mul(vec3_sub(target_point, data->scene.camera.position),
// 					zoom_factor));
// 	render_threaded(data);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   mouse.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

void	ft_zoom(t_data *data, double zoom_factor)
{
	data->scene.camera.fov -= zoom_factor;
	if (data->scene.camera.fov < 10)
		data->scene.camera.fov = 10;
	if (data->scene.camera.fov > 170)
		data->scene.camera.fov = 170;
}

void	init_mouse_state(t_data *data)
{
	data->mouse_state.is_pressed = false;
	data->mouse_state.last_x = 0.0;
	data->mouse_state.last_y = 0.0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   window.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../include/minirt.h"

// moving
// mlx_key_hook(data->mlx.mlx_ptr, key_hook, data);
// mlx_scroll_hook(data->mlx.mlx_ptr, scroll_hook, data);
// mlx_cursor_hook(data->mlx.mlx_ptr, mouse_move_hook, data);
// mlx_mouse_hook(data->mlx.mlx_ptr, mouse_press_hook, data);
// mlx_loop_hook(data->mlx.mlx_ptr, auto_rotate, data);
// mlx_loop_hook(data->mlx.mlx_ptr, animate_lights, data);
int	mlx_setup(t_data *data)
{
	data->mlx.mlx_ptr = mlx_init(data->scene.width, data->scene.height,
			"miniRT", true);
	if (!data->mlx.mlx_ptr)
		return (1);
	data->mlx.img.img_ptr = mlx_new_image(data->mlx.mlx_ptr, data->scene.width,
			data->scene.height);
	if (!data->mlx.img.img_ptr)
	{
		mlx_terminate(data->mlx.mlx_ptr);
		return (1);
	}
	if (mlx_image_to_window(data->mlx.mlx_ptr, data->mlx.img.img_ptr, 0, 0) < 0)
	{
		mlx_terminate(data->mlx.mlx_ptr);
		return (1);
	}
	return (0);
}

int	close_window(t_data *data)
{
	cleanup_program(data);
	exit(0);
	return (0);
}
-rw-r--r-- 1 root   root   233K sep 23 16:06 doc
-rwxrwxrwx 1 root   root    15K sep 23 14:25 include/minirt.h
-rwxrwxrwx 1 root   root   6,7K sep 23 14:11 Makefile
-rwxrwxrwx 1 root   root   1,3K sep 23 14:11 MLX42/cmake/Findglfw3.cmake
-rwxrwxrwx 1 root   root   1,4K sep 23 14:11 MLX42/cmake/LinkGLFW.cmake
-rwxrwxrwx 1 root   root   6,1K sep 23 14:11 MLX42/CMakeLists.txt
-rwxrwxrwx 1 root   root   4,7K sep 23 14:11 MLX42/CODE_OF_CONDUCT.md
-rwxrwxrwx 1 root   root    891 sep 23 14:11 MLX42/CONTRIBUTING.md
-rwxrwxrwx 1 root   root    14K sep 23 14:11 MLX42/docs/42.md
-rwxrwxrwx 1 root   root   4,8M sep 23 14:11 MLX42/docs/assets/demo.gif
-rwxrwxrwx 1 root   root   3,8K sep 23 14:11 MLX42/docs/assets/logo.png
-rwxrwxrwx 1 root   root   4,0K sep 23 14:11 MLX42/docs/Basics.md
-rwxrwxrwx 1 root   root   3,0K sep 23 14:11 MLX42/docs/Colors.md
-rwxrwxrwx 1 root   root    390 sep 23 14:11 MLX42/docs/Functions.md
-rwxrwxrwx 1 root   root   6,1K sep 23 14:11 MLX42/docs/Hooks.md
-rwxrwxrwx 1 root   root   4,1K sep 23 14:11 MLX42/docs/Images.md
-rwxrwxrwx 1 root   root   6,9K sep 23 14:11 MLX42/docs/index.md
-rwxrwxrwx 1 root   root   1,7K sep 23 14:11 MLX42/docs/Input.md
-rwxrwxrwx 1 root   root   1,5K sep 23 14:11 MLX42/docs/Shaders.md
-rwxrwxrwx 1 root   root   2,6K sep 23 14:11 MLX42/docs/Textures.md
-rwxrwxrwx 1 root   root   3,0K sep 23 14:11 MLX42/docs/XPM42.md
-rwxrwxrwx 1 root   root   279K sep 23 14:11 MLX42/include/glad/glad.h
-rwxrwxrwx 1 root   root    12K sep 23 14:11 MLX42/include/KHR/khrplatform.h
-rwxrwxrwx 1 root   root   101K sep 23 14:11 MLX42/include/lodepng/lodepng.h
-rwxrwxrwx 1 root   root    28K sep 23 14:11 MLX42/include/MLX42/MLX42.h
-rwxrwxrwx 1 root   root   6,9K sep 23 14:11 MLX42/include/MLX42/MLX42_Int.h
-rwxrwxrwx 1 root   root   150K sep 23 14:11 MLX42/lib/glad/glad.c
-rwxrwxrwx 1 root   root   296K sep 23 14:11 MLX42/lib/png/lodepng.c
-rwxrwxrwx 1 root   root    18K sep 23 14:11 MLX42/LICENSE
-rwxrwxrwx 1 root   root    13K sep 23 14:11 MLX42/README.md
-rwxrwxrwx 1 root   root    337 sep 23 14:11 MLX42/SECURITY.md
-rwxrwxrwx 1 root   root   1,7K sep 23 14:11 MLX42/shaders/default.frag
-rwxrwxrwx 1 root   root    310 sep 23 14:11 MLX42/shaders/default.vert
-rwxrwxrwx 1 root   root   264K sep 23 14:11 MLX42/src/font/font.h
-rwxrwxrwx 1 root   root   2,6K sep 23 14:11 MLX42/src/font/mlx_font.c
-rwxrwxrwx 1 root   root   2,0K sep 23 14:11 MLX42/src/mlx_cursor.c
-rwxrwxrwx 1 root   root   1,8K sep 23 14:11 MLX42/src/mlx_exit.c
-rwxrwxrwx 1 root   root   7,6K sep 23 14:11 MLX42/src/mlx_images.c
-rwxrwxrwx 1 root   root   7,8K sep 23 14:11 MLX42/src/mlx_init.c
-rwxrwxrwx 1 root   root   1,7K sep 23 14:11 MLX42/src/mlx_keys.c
-rwxrwxrwx 1 root   root   3,5K sep 23 14:11 MLX42/src/mlx_loop.c
-rwxrwxrwx 1 root   root   1,4K sep 23 14:11 MLX42/src/mlx_monitor.c
-rwxrwxrwx 1 root   root   3,1K sep 23 14:11 MLX42/src/mlx_mouse.c
-rwxrwxrwx 1 root   root   1,6K sep 23 14:11 MLX42/src/mlx_put_pixel.c
-rwxrwxrwx 1 root   root   3,9K sep 23 14:11 MLX42/src/mlx_window.c
-rwxrwxrwx 1 root   root   1,5K sep 23 14:11 MLX42/src/textures/mlx_png.c
-rwxrwxrwx 1 root   root   1,6K sep 23 14:11 MLX42/src/textures/mlx_texture.c
-rwxrwxrwx 1 root   root   7,2K sep 23 14:11 MLX42/src/textures/mlx_xpm42.c
-rwxrwxrwx 1 root   root   1,3K sep 23 14:11 MLX42/src/utils/mlx_compare.c
-rwxrwxrwx 1 root   root   2,1K sep 23 14:11 MLX42/src/utils/mlx_error.c
-rwxrwxrwx 1 root   root   4,0K sep 23 14:11 MLX42/src/utils/mlx_list.c
-rwxrwxrwx 1 root   root   3,7K sep 23 14:11 MLX42/src/utils/mlx_utils.c
-rwxrwxrwx 1 root   root   1,3K sep 23 14:11 MLX42/tests/CMakeLists.txt
-rwxrwxrwx 1 root   root   3,8K sep 23 14:11 MLX42/tests/tests.cpp
-rwxrwxrwx 1 root   root    978 sep 23 14:11 MLX42/tests/WindowFixture.hpp
-rwxrwxrwx 1 root   root   1,8K sep 23 14:11 MLX42/tools/compile_shader.bat
-rwxrwxrwx 1 root   root   1,6K sep 23 14:11 MLX42/tools/compile_shader.sh
-rwxrwxrwx 1 root   root    19K sep 23 14:11 MLX42/tools/xpm3_conv.py
-rwxrwxrwx 1 root   root   5,9K sep 23 14:11 MLX42/web/coi-serviceworker.js
-rwxrwxrwx 1 root   root   205K sep 23 14:11 MLX42/web/demo.js
-rwxrwxrwx 1 root   root   111K sep 23 14:11 MLX42/web/demo.wasm
-rwxrwxrwx 1 root   root   4,0K sep 23 14:11 MLX42/web/index.html
-rwxrwxrwx 1 root   root   5,0K sep 23 14:11 MLX42/web/README.md
-rwxrwxrwx 1 root   root    155 sep 23 14:36 scene/basic.rt
-rwxrwxrwx 1 root   root   1,4K sep 23 14:36 scene/bonus_basic.rt
-rwxrwxrwx 1 root   root   1,1K sep 23 14:11 scene/bonus.rt
-rwxrwxrwx 1 root   root    871 sep 23 14:11 scene/home.rt
-rwxrwxrwx 1 root   root    398 sep 23 14:11 scene/ladrillo.rt
-rwxrwxrwx 1 root   root   2,4K sep 23 15:09 scene/map.rt
-rwxrwxrwx 1 root   root    372 sep 23 15:01 scene/maps/figures/cone.rt
-rwxrwxrwx 1 root   root    376 sep 23 14:54 scene/maps/figures/cylinder.rt
-rwxrwxrwx 1 root   root    391 sep 23 15:12 scene/maps/figures/hyperboloid.rt
-rwxrwxrwx 1 root   root    371 sep 23 15:04 scene/maps/figures/paraboloide.rt
-rwxrwxrwx 1 root   root    324 sep 23 14:53 scene/maps/figures/plane.rt
-rwxrwxrwx 1 root   root    318 sep 23 14:53 scene/maps/figures/sphere.rt
-rwxrwxrwx 1 root   root    283 sep 23 16:03 scene/maps/materials/sphere_gold.rt
-rwxrwxrwx 1 root   root   1,8K sep 23 15:25 scene/maps/mir/cone_mir.rt
-rwxrwxrwx 1 root   root   1,7K sep 23 15:27 scene/maps/mir/cylinder_mir.rt
-rwxrwxrwx 1 root   root   1,8K sep 23 15:29 scene/maps/mir/hyperbolid_mir.rt
-rwxrwxrwx 1 root   root   1,6K sep 23 15:33 scene/maps/mir/parabolid_mir.rt
-rwxrwxrwx 1 root   root   1,6K sep 23 15:26 scene/maps/mir/sphere_mir.rt
-rwxrwxrwx 1 root   root   1,8K sep 23 15:34 scene/maps/spc/cone_spc.rt
-rwxrwxrwx 1 root   root   1,7K sep 23 15:37 scene/maps/spc/cylinder_spc.rt
-rwxrwxrwx 1 root   root   1,7K sep 23 15:35 scene/maps/spc/parabolid_spc.rt
-rwxrwxrwx 1 root   root   1,7K sep 23 15:34 scene/maps/spc/sphere_spc.rt
-rwxrwxrwx 1 root   root    455 sep 23 14:36 scene/mir.rt
-rwxrwxrwx 1 root   root   1,3K sep 23 14:11 scene/moon.rt
-rwxrwxrwx 1 root   root   1011 sep 23 14:11 scene/new.rt
-rwxrwxrwx 1 root   root   1,8K sep 23 14:11 scene/pato.rt
-rwxrwxrwx 1 root   root    222 sep 23 14:11 scene/plane.rt
-rwxrwxrwx 1 root   root   1,4K sep 23 14:11 scene/pocoyo.rt
-rwxrwxrwx 1 root   root    871 sep 23 14:11 scene/pop.rt
-rwxrwxrwx 1 root   root    356 sep 23 14:36 scene/rock.rt
-rwxrwxrwx 1 root   root    342 sep 23 14:11 scene/scene_bonus.rt
-rwxrwxrwx 1 root   root      0 sep 23 14:11 scene/scene_empty.rt
-rwxrwxrwx 1 root   root      0 sep 23 14:11 scene/scene_wrong.rf
-rwxrwxrwx 1 root   root   5,7M sep 23 14:11 scene/sky.jpg
-rwxrwxrwx 1 root   root   1,5K sep 23 14:36 scene/special/room.rt
-rwxrwxrwx 1 root   root    202 sep 23 15:39 scene/special/spc.rt
-rwxrwxrwx 1 root   root    927 sep 23 14:11 scene/sphere.rt
-rwxrwxrwx 1 root   root    15M sep 23 14:11 scene/texture/ar_color.png
-rwxrwxrwx 1 root   root    18M sep 23 14:11 scene/texture/ar_normal.png
-rwxrwxrwx 1 root   root   3,9M sep 23 14:11 scene/texture/baldosa_color_black.png
-rwxrwxrwx 1 root   root   8,6M sep 23 14:11 scene/texture/baldosa_normal.png
-rwxrwxrwx 1 root   root   6,0M sep 23 14:36 scene/texture/cuero_color.png
-rwxrwxrwx 1 root   root    27M sep 23 14:36 scene/texture/cuero_normal.png
-rw-r--r-- 1 cronos cronos 6,8M sep 23 15:55 scene/texture/gold_color.png
-rw-r--r-- 1 cronos cronos  21M sep 23 13:50 scene/texture/gold_normal.png
-rwxrwxrwx 1 root   root    39M sep 23 14:11 scene/texture/grass_color.png
-rwxrwxrwx 1 root   root    41M sep 23 14:11 scene/texture/grass_normal.png
-rwxrwxrwx 1 root   root    22M sep 23 14:11 scene/texture/ladrillo_color.png
-rwxrwxrwx 1 root   root    29M sep 23 14:11 scene/texture/ladrillo_normal.png
-rwxrwxrwx 1 root   root    15M sep 23 14:11 scene/texture/madera_color.png
-rwxrwxrwx 1 root   root    19M sep 23 14:11 scene/texture/madera_normal.png
-rwxrwxrwx 1 root   root    30M sep 23 14:36 scene/texture/oxido_color.png
-rwxrwxrwx 1 root   root    33M sep 23 14:36 scene/texture/oxido_normal.png
-rwxrwxrwx 1 root   root    16M sep 23 14:11 scene/texture/piscine_color.png
-rwxrwxrwx 1 root   root   6,0M sep 23 14:11 scene/texture/piscine_normal.png
-rwxrwxrwx 1 root   root    24M sep 23 14:36 scene/texture/rock_color.png
-rwxrwxrwx 1 root   root    35M sep 23 14:36 scene/texture/rock_normal.png
-rwxrwxrwx 1 root   root    12M sep 23 14:11 scene/texture/sky.png
-rwxrwxrwx 1 root   root   9,2M sep 23 14:11 scene/texture/techo_color.png
-rwxrwxrwx 1 root   root    15M sep 23 14:11 scene/texture/techo_normal.png
-rwxrwxrwx 1 root   root   381K sep 23 14:11 scene/texture/water_color.png
-rwxrwxrwx 1 root   root   430K sep 23 14:11 scene/texture/water_normal.png
-rwxrwxrwx 1 root   root    12M sep 23 14:11 scene/texture/water.png
-rwxrwxrwx 1 root   root   1,2K sep 23 14:11 scene/tink.rt
-rwxrwxrwx 1 root   root    90K sep 23 14:36 scene/views/basic.png
-rwxrwxrwx 1 root   root   300K sep 23 14:36 scene/views/bonus_basic.png
-rwxrwxrwx 1 root   root   2,7M sep 23 14:36 scene/views/ladrillo.png
-rwxrwxrwx 1 root   root   3,2M sep 23 14:36 scene/views/map.png
-rwxrwxrwx 1 root   root   4,1M sep 23 14:36 scene/views/mir.png
-rwxrwxrwx 1 root   root   2,9M sep 23 14:36 scene/views/rock.png
-rwxrwxrwx 1 root   root   861K sep 23 14:36 scene/views/room.png
-rwxrwxrwx 1 root   root   254K sep 23 14:36 scene/views/spc.png
-rwxrwxrwx 1 root   root   205K sep 23 14:36 scene/views/sphere_mir.png
-rwxrwxrwx 1 root   root   815K sep 23 14:36 scene/views/sphere.png
-rwxrwxrwx 1 root   root   197K sep 23 14:36 scene/views/sphere_spc.png
-rwxrwxrwx 1 root   root   1,4M sep 23 14:36 scene/views/tink.png
-rwxrwxrwx 1 root   root    870 sep 23 15:44 scene/water.rt
-rwxrwxrwx 1 root   root   1,1K sep 23 14:11 src/clean/clean_data_2.c
-rwxrwxrwx 1 root   root   2,2K sep 23 14:11 src/clean/clean_data.c
-rwxrwxrwx 1 root   root   2,3K sep 23 14:11 src/inits/init_basics.c
-rwxrwxrwx 1 root   root   1,5K sep 23 14:11 src/inits/init_color.c
-rwxrwxrwx 1 root   root   1,8K sep 23 14:11 src/inits/init_elements.c
-rwxrwxrwx 1 root   root   2,1K sep 23 14:11 src/inits/init_figures.c
-rwxrwxrwx 1 root   root   1,6K sep 23 14:11 src/libft/ft_atof.c
-rwxrwxrwx 1 root   root   1,4K sep 23 14:11 src/libft/ft_atoi.c
-rwxrwxrwx 1 root   root   1,3K sep 23 14:11 src/libft/ft_atol.c
-rwxrwxrwx 1 root   root   1,1K sep 23 14:11 src/libft/ft_bzero.c
-rwxrwxrwx 1 root   root   1,2K sep 23 14:11 src/libft/ft_calloc.c
-rwxrwxrwx 1 root   root   1001 sep 23 14:11 src/libft/ft_fabs.c
-rwxrwxrwx 1 root   root   2,0K sep 23 14:11 src/libft/ft_flags.c
-rwxrwxrwx 1 root   root   1,3K sep 23 14:11 src/libft/ft_getenv.c
-rwxrwxrwx 1 root   root    979 sep 23 14:11 src/libft/ft_isalnum.c
-rwxrwxrwx 1 root   root    997 sep 23 14:11 src/libft/ft_isalpha.c
-rwxrwxrwx 1 root   root    967 sep 23 14:11 src/libft/ft_isascii.c
-rwxrwxrwx 1 root   root    969 sep 23 14:11 src/libft/ft_isdigit.c
-rwxrwxrwx 1 root   root    968 sep 23 14:11 src/libft/ft_isprint.c
-rwxrwxrwx 1 root   root   7,8K sep 23 14:11 src/libft/ft_itoa.c
-rwxrwxrwx 1 root   root   1,1K sep 23 14:11 src/libft/ft_lstadd_back_bonus.c
-rwxrwxrwx 1 root   root   1,1K sep 23 14:11 src/libft/ft_lstadd_front_bonus.c
-rwxrwxrwx 1 root   root   1,1K sep 23 14:11 src/libft/ft_lstclear_bonus.c
-rwxrwxrwx 1 root   root   1,1K sep 23 14:11 src/libft/ft_lstdelone_bonus.c
-rwxrwxrwx 1 root   root   1,1K sep 23 14:11 src/libft/ft_lstiter_bonus.c
-rwxrwxrwx 1 root   root   1,1K sep 23 14:11 src/libft/ft_lstlast_bonus.c
-rwxrwxrwx 1 root   root   1,3K sep 23 14:11 src/libft/ft_lstmap_bonus.c
-rwxrwxrwx 1 root   root   1,1K sep 23 14:11 src/libft/ft_lstnew_bonus.c
-rwxrwxrwx 1 root   root   1,1K sep 23 14:11 src/libft/ft_lstsize_bonus.c
-rwxrwxrwx 1 root   root   1,2K sep 23 14:11 src/libft/ft_memchr.c
-rwxrwxrwx 1 root   root   1,4K sep 23 14:11 src/libft/ft_memcmp.c
-rwxrwxrwx 1 root   root   1,2K sep 23 14:11 src/libft/ft_memcpy.c
-rwxrwxrwx 1 root   root   1,3K sep 23 14:11 src/libft/ft_memmove.c
-rwxrwxrwx 1 root   root   1,3K sep 23 14:11 src/libft/ft_memset.c
-rwxrwxrwx 1 root   root   1,4K sep 23 14:11 src/libft/ft_printf.c
-rwxrwxrwx 1 root   root   2,9K sep 23 14:11 src/libft/ft_printf_utils.c
-rwxrwxrwx 1 root   root    969 sep 23 14:11 src/libft/ft_putchar_fd.c
-rwxrwxrwx 1 root   root   1,1K sep 23 14:11 src/libft/ft_putendl_fd.c
-rwxrwxrwx 1 root   root   1,2K sep 23 14:11 src/libft/ft_putnbr_fd.c
-rwxrwxrwx 1 root   root   1006 sep 23 14:11 src/libft/ft_putstr_fd.c
-rwxrwxrwx 1 root   root   1,2K sep 23 14:11 src/libft/ft_realloc.c
-rwxrwxrwx 1 root   root   2,2K sep 23 14:11 src/libft/ft_split.c
-rwxrwxrwx 1 root   root   1,3K sep 23 14:11 src/libft/ft_sqrt.c
-rwxrwxrwx 1 root   root   1,4K sep 23 14:11 src/libft/ft_strchr.c
-rwxrwxrwx 1 root   root   1,1K sep 23 14:11 src/libft/ft_strcmp.c
-rwxrwxrwx 1 root   root   1,2K sep 23 14:11 src/libft/ft_strdup.c
-rwxrwxrwx 1 root   root   1,1K sep 23 14:11 src/libft/ft_striteri.c
-rwxrwxrwx 1 root   root   1,5K sep 23 14:11 src/libft/ft_strjoin.c
-rwxrwxrwx 1 root   root   1,3K sep 23 14:11 src/libft/ft_strlcat.c
-rwxrwxrwx 1 root   root   1,2K sep 23 14:11 src/libft/ft_strlcpy.c
-rwxrwxrwx 1 root   root   1,1K sep 23 14:11 src/libft/ft_strlen.c
-rwxrwxrwx 1 root   root   1,3K sep 23 14:11 src/libft/ft_strmapi.c
-rwxrwxrwx 1 root   root   1,3K sep 23 14:11 src/libft/ft_strncmp.c
-rwxrwxrwx 1 root   root   1,5K sep 23 14:11 src/libft/ft_strnstr.c
-rwxrwxrwx 1 root   root   1,4K sep 23 14:11 src/libft/ft_strrchr.c
-rwxrwxrwx 1 root   root   1,6K sep 23 14:11 src/libft/ft_strtrim.c
-rwxrwxrwx 1 root   root   2,8K sep 23 14:11 src/libft/ft_substr.c
-rwxrwxrwx 1 root   root   1,2K sep 23 14:11 src/libft/ft_tolower.c
-rwxrwxrwx 1 root   root   1,1K sep 23 14:11 src/libft/ft_toupper.c
-rwxrwxrwx 1 root   root   2,2K sep 23 14:11 src/libft/get_next_line.c
-rwxrwxrwx 1 root   root   2,3K sep 23 14:11 src/libft/get_next_line_utils.c
-rwxrwxrwx 1 root   root   5,0K sep 23 14:11 src/libft/libft.h
-rwxrwxrwx 1 root   root   2,8K sep 23 14:11 src/libft/Makefile
-rwxrwxrwx 1 root   root   1,6K sep 23 14:11 src/libft/README.md
-rwxrwxrwx 1 root   root   1,8K sep 23 14:11 src/main.c
-rwxrwxrwx 1 root   root   1020 sep 23 14:11 src/parser/ft_error.c
-rwxrwxrwx 1 root   root   3,1K sep 23 14:11 src/parser/parser.c
-rwxrwxrwx 1 root   root   4,0K sep 23 14:11 src/parser/parser_elements_2.c
-rwxrwxrwx 1 root   root   3,8K sep 23 14:11 src/parser/parser_elements.c
-rwxrwxrwx 1 root   root   2,6K sep 23 14:11 src/parser/parser_utils_2.c
-rwxrwxrwx 1 root   root   2,2K sep 23 14:37 src/parser/parser_utils_3.c
-rwxrwxrwx 1 root   root   3,3K sep 23 14:11 src/parser/parser_utils.c
-rwxrwxrwx 1 root   root   3,0K sep 23 14:36 src/parser/parser_utils_materials_2.c
-rwxrwxrwx 1 root   root   2,6K sep 23 14:11 src/parser/parser_utils_materials.c
-rwxrwxrwx 1 root   root   3,0K sep 23 14:11 src/render/animation/animate_lights.c
-rwxrwxrwx 1 root   root   1,7K sep 23 14:11 src/render/animation/auto_rotate.c
-rwxrwxrwx 1 root   root   1,6K sep 23 14:11 src/render/ft_color.c
-rwxrwxrwx 1 root   root   4,1K sep 23 14:11 src/render/ft_normal_mapping.c
-rwxrwxrwx 1 root   root   6,5K sep 23 14:11 src/render/ft_ray.c
-rwxrwxrwx 1 root   root   4,3K sep 23 14:11 src/render/intersect/ft_cone.c
-rwxrwxrwx 1 root   root   7,6K sep 23 14:11 src/render/intersect/ft_cylinder.c
-rwxrwxrwx 1 root   root   2,0K sep 23 14:11 src/render/intersect/ft_cylinder_utils.c
-rwxrwxrwx 1 root   root   3,9K sep 23 14:11 src/render/intersect/ft_hyperboloid.c
-rwxrwxrwx 1 root   root   6,0K sep 23 14:11 src/render/intersect/ft_paraboloid.c
-rwxrwxrwx 1 root   root   1,5K sep 23 14:11 src/render/intersect/ft_plane.c
-rwxrwxrwx 1 root   root   2,3K sep 23 14:11 src/render/intersect/ft_sphere.c
-rwxrwxrwx 1 root   root   8,3K sep 23 14:11 src/render/light/ft_light.c
-rwxrwxrwx 1 root   root   3,1K sep 23 14:11 src/render/light/ft_light_utils.c
-rwxrwxrwx 1 root   root   3,6K sep 23 14:11 src/render/light/ft_specular_light.c
-rwxrwxrwx 1 root   root   2,2K sep 23 14:11 src/render/mapping/ft_texture.c
-rwxrwxrwx 1 root   root   1,6K sep 23 14:11 src/render/mapping/get_uv_cone.c
-rwxrwxrwx 1 root   root   1,7K sep 23 14:11 src/render/mapping/get_uv_cylinder.c
-rwxrwxrwx 1 root   root   1,6K sep 23 14:11 src/render/mapping/get_uv_hyperboloid.c
-rwxrwxrwx 1 root   root   2,7K sep 23 14:11 src/render/mapping/get_uv_paraboloid.c
-rwxrwxrwx 1 root   root   2,6K sep 23 14:11 src/render/mapping/get_uv_plane.c
-rwxrwxrwx 1 root   root   1,3K sep 23 14:11 src/render/mapping/get_uv_sphere.c
-rwxrwxrwx 1 root   root   4,2K sep 23 14:11 src/render/render.c
-rwxrwxrwx 1 root   root   4,7K sep 23 14:11 src/render/thread.c
-rwxrwxrwx 1 root   root   1,1K sep 23 14:11 src/utils/nthreads.c
-rwxrwxrwx 1 root   root   1019 sep 23 14:11 src/utils/ray_at.c
-rwxrwxrwx 1 root   root   1008 sep 23 14:11 src/vector/vec2/vec2_dot.c
-rwxrwxrwx 1 root   root   1,0K sep 23 14:11 src/vector/vec2/vec2_init.c
-rwxrwxrwx 1 root   root    997 sep 23 14:11 src/vector/vec2/vec2_length.c
-rwxrwxrwx 1 root   root   1,1K sep 23 14:11 src/vector/vec2/vec2_normalize.c
-rwxrwxrwx 1 root   root   1,6K sep 23 14:11 src/vector/vec3/ft_rotate_vector.c
-rwxrwxrwx 1 root   root   1,1K sep 23 14:11 src/vector/vec3/vec3_add.c
-rwxrwxrwx 1 root   root   1,1K sep 23 14:11 src/vector/vec3/vec3_cross.c
-rwxrwxrwx 1 root   root   1,1K sep 23 14:11 src/vector/vec3/vec3_div.c
-rwxrwxrwx 1 root   root   1023 sep 23 14:11 src/vector/vec3/vec3_dot.c
-rwxrwxrwx 1 root   root   1,1K sep 23 14:11 src/vector/vec3/vec3_init.c
-rwxrwxrwx 1 root   root    995 sep 23 14:11 src/vector/vec3/vec3_length.c
-rwxrwxrwx 1 root   root    997 sep 23 14:11 src/vector/vec3/vec3_length_squared.c
-rwxrwxrwx 1 root   root   1,1K sep 23 14:11 src/vector/vec3/vec3_mul.c
-rwxrwxrwx 1 root   root   1,1K sep 23 14:11 src/vector/vec3/vec3_mult_vec.c
-rwxrwxrwx 1 root   root   1,1K sep 23 14:11 src/vector/vec3/vec3_normalize.c
-rwxrwxrwx 1 root   root   1,1K sep 23 14:11 src/vector/vec3/vec3_reflect.c
-rwxrwxrwx 1 root   root   1,1K sep 23 14:11 src/vector/vec3/vec3_sub.c
-rwxrwxrwx 1 root   root   5,1K sep 23 14:11 src/windows/hook.c
-rwxrwxrwx 1 root   root   1,3K sep 23 14:11 src/windows/mouse.c
-rwxrwxrwx 1 root   root   1,9K sep 23 14:11 src/windows/window.c

include:
total 16K
drwxrwxrwx 1 root root  16 sep 23 14:11 .
drwxrwxrwx 1 root root  70 sep 23 16:06 ..
-rwxrwxrwx 1 root root 15K sep 23 14:25 minirt.h

MLX42:
total 68K
drwxrwxrwx 1 root root  294 sep 23 16:05 .
drwxrwxrwx 1 root root   70 sep 23 16:06 ..
drwxrwxrwx 1 root root   58 sep 23 14:11 cmake
-rwxrwxrwx 1 root root 6,1K sep 23 14:11 CMakeLists.txt
-rwxrwxrwx 1 root root 4,7K sep 23 14:11 CODE_OF_CONDUCT.md
-rwxrwxrwx 1 root root  891 sep 23 14:11 CONTRIBUTING.md
drwxrwxrwx 1 root root  206 sep 23 14:11 docs
-rw-r--r-- 1 root root  287 sep 23 14:11 .gitattributes
drwxr-xr-x 1 root root   46 sep 23 14:11 .github
-rw-r--r-- 1 root root  573 sep 23 14:11 .gitignore
drwxrwxrwx 1 root root   38 sep 23 14:11 include
drwxrwxrwx 1 root root   14 sep 23 14:11 lib
-rwxrwxrwx 1 root root  18K sep 23 14:11 LICENSE
-rwxrwxrwx 1 root root  13K sep 23 14:11 README.md
-rwxrwxrwx 1 root root  337 sep 23 14:11 SECURITY.md
drwxrwxrwx 1 root root   48 sep 23 14:11 shaders
drwxrwxrwx 1 root root  264 sep 23 14:11 src
drwxrwxrwx 1 root root   80 sep 23 14:11 tests
drwxrwxrwx 1 root root   94 sep 23 14:11 tools
drwxrwxrwx 1 root root  110 sep 23 14:11 web

MLX42/cmake:
total 8,0K
drwxrwxrwx 1 root root   58 sep 23 14:11 .
drwxrwxrwx 1 root root  294 sep 23 16:05 ..
-rwxrwxrwx 1 root root 1,3K sep 23 14:11 Findglfw3.cmake
-rwxrwxrwx 1 root root 1,4K sep 23 14:11 LinkGLFW.cmake

MLX42/docs:
total 68K
drwxrwxrwx 1 root root  206 sep 23 14:11 .
drwxrwxrwx 1 root root  294 sep 23 16:05 ..
-rwxrwxrwx 1 root root  14K sep 23 14:11 42.md
drwxrwxrwx 1 root root   32 sep 23 14:11 assets
-rwxrwxrwx 1 root root 4,0K sep 23 14:11 Basics.md
-rwxrwxrwx 1 root root 3,0K sep 23 14:11 Colors.md
-rwxrwxrwx 1 root root  390 sep 23 14:11 Functions.md
-rwxrwxrwx 1 root root 6,1K sep 23 14:11 Hooks.md
-rwxrwxrwx 1 root root 4,1K sep 23 14:11 Images.md
-rwxrwxrwx 1 root root 6,9K sep 23 14:11 index.md
-rwxrwxrwx 1 root root 1,7K sep 23 14:11 Input.md
-rwxrwxrwx 1 root root 1,5K sep 23 14:11 Shaders.md
-rwxrwxrwx 1 root root 2,6K sep 23 14:11 Textures.md
-rwxrwxrwx 1 root root 3,0K sep 23 14:11 XPM42.md

MLX42/docs/assets:
total 4,8M
drwxrwxrwx 1 root root   32 sep 23 14:11 .
drwxrwxrwx 1 root root  206 sep 23 14:11 ..
-rwxrwxrwx 1 root root 4,8M sep 23 14:11 demo.gif
-rwxrwxrwx 1 root root 3,8K sep 23 14:11 logo.png

MLX42/include:
total 0
drwxrwxrwx 1 root root  38 sep 23 14:11 .
drwxrwxrwx 1 root root 294 sep 23 16:05 ..
drwxrwxrwx 1 root root  12 sep 23 14:11 glad
drwxrwxrwx 1 root root  26 sep 23 14:11 KHR
drwxrwxrwx 1 root root  18 sep 23 14:11 lodepng
drwxrwxrwx 1 root root  36 sep 23 14:11 MLX42

MLX42/include/glad:
total 280K
drwxrwxrwx 1 root root   12 sep 23 14:11 .
drwxrwxrwx 1 root root   38 sep 23 14:11 ..
-rwxrwxrwx 1 root root 279K sep 23 14:11 glad.h

MLX42/include/KHR:
total 12K
drwxrwxrwx 1 root root  26 sep 23 14:11 .
drwxrwxrwx 1 root root  38 sep 23 14:11 ..
-rwxrwxrwx 1 root root 12K sep 23 14:11 khrplatform.h

MLX42/include/lodepng:
total 104K
drwxrwxrwx 1 root root   18 sep 23 14:11 .
drwxrwxrwx 1 root root   38 sep 23 14:11 ..
-rwxrwxrwx 1 root root 101K sep 23 14:11 lodepng.h

MLX42/include/MLX42:
total 36K
drwxrwxrwx 1 root root   36 sep 23 14:11 .
drwxrwxrwx 1 root root   38 sep 23 14:11 ..
-rwxrwxrwx 1 root root  28K sep 23 14:11 MLX42.h
-rwxrwxrwx 1 root root 6,9K sep 23 14:11 MLX42_Int.h

MLX42/lib:
total 0
drwxrwxrwx 1 root root  14 sep 23 14:11 .
drwxrwxrwx 1 root root 294 sep 23 16:05 ..
drwxrwxrwx 1 root root  12 sep 23 14:11 glad
drwxrwxrwx 1 root root  18 sep 23 14:11 png

MLX42/lib/glad:
total 152K
drwxrwxrwx 1 root root   12 sep 23 14:11 .
drwxrwxrwx 1 root root   14 sep 23 14:11 ..
-rwxrwxrwx 1 root root 150K sep 23 14:11 glad.c

MLX42/lib/png:
total 296K
drwxrwxrwx 1 root root   18 sep 23 14:11 .
drwxrwxrwx 1 root root   14 sep 23 14:11 ..
-rwxrwxrwx 1 root root 296K sep 23 14:11 lodepng.c

MLX42/shaders:
total 8,0K
drwxrwxrwx 1 root root   48 sep 23 14:11 .
drwxrwxrwx 1 root root  294 sep 23 16:05 ..
-rwxrwxrwx 1 root root 1,7K sep 23 14:11 default.frag
-rwxrwxrwx 1 root root  310 sep 23 14:11 default.vert

MLX42/src:
total 48K
drwxrwxrwx 1 root root  264 sep 23 14:11 .
drwxrwxrwx 1 root root  294 sep 23 16:05 ..
drwxrwxrwx 1 root root   32 sep 23 14:11 font
-rwxrwxrwx 1 root root 2,0K sep 23 14:11 mlx_cursor.c
-rwxrwxrwx 1 root root 1,8K sep 23 14:11 mlx_exit.c
-rwxrwxrwx 1 root root 7,6K sep 23 14:11 mlx_images.c
-rwxrwxrwx 1 root root 7,8K sep 23 14:11 mlx_init.c
-rwxrwxrwx 1 root root 1,7K sep 23 14:11 mlx_keys.c
-rwxrwxrwx 1 root root 3,5K sep 23 14:11 mlx_loop.c
-rwxrwxrwx 1 root root 1,4K sep 23 14:11 mlx_monitor.c
-rwxrwxrwx 1 root root 3,1K sep 23 14:11 mlx_mouse.c
-rwxrwxrwx 1 root root 1,6K sep 23 14:11 mlx_put_pixel.c
-rwxrwxrwx 1 root root 3,9K sep 23 14:11 mlx_window.c
drwxrwxrwx 1 root root   66 sep 23 14:11 textures
drwxrwxrwx 1 root root   90 sep 23 14:11 utils

MLX42/src/font:
total 268K
drwxrwxrwx 1 root root   32 sep 23 14:11 .
drwxrwxrwx 1 root root  264 sep 23 14:11 ..
-rwxrwxrwx 1 root root 264K sep 23 14:11 font.h
-rwxrwxrwx 1 root root 2,6K sep 23 14:11 mlx_font.c

MLX42/src/textures:
total 16K
drwxrwxrwx 1 root root   66 sep 23 14:11 .
drwxrwxrwx 1 root root  264 sep 23 14:11 ..
-rwxrwxrwx 1 root root 1,5K sep 23 14:11 mlx_png.c
-rwxrwxrwx 1 root root 1,6K sep 23 14:11 mlx_texture.c
-rwxrwxrwx 1 root root 7,2K sep 23 14:11 mlx_xpm42.c

MLX42/src/utils:
total 16K
drwxrwxrwx 1 root root   90 sep 23 14:11 .
drwxrwxrwx 1 root root  264 sep 23 14:11 ..
-rwxrwxrwx 1 root root 1,3K sep 23 14:11 mlx_compare.c
-rwxrwxrwx 1 root root 2,1K sep 23 14:11 mlx_error.c
-rwxrwxrwx 1 root root 4,0K sep 23 14:11 mlx_list.c
-rwxrwxrwx 1 root root 3,7K sep 23 14:11 mlx_utils.c

MLX42/tests:
total 12K
drwxrwxrwx 1 root root   80 sep 23 14:11 .
drwxrwxrwx 1 root root  294 sep 23 16:05 ..
-rwxrwxrwx 1 root root 1,3K sep 23 14:11 CMakeLists.txt
-rwxrwxrwx 1 root root 3,8K sep 23 14:11 tests.cpp
-rwxrwxrwx 1 root root  978 sep 23 14:11 WindowFixture.hpp

MLX42/tools:
total 28K
drwxrwxrwx 1 root root   94 sep 23 14:11 .
drwxrwxrwx 1 root root  294 sep 23 16:05 ..
-rwxrwxrwx 1 root root 1,8K sep 23 14:11 compile_shader.bat
-rwxrwxrwx 1 root root 1,6K sep 23 14:11 compile_shader.sh
-rwxrwxrwx 1 root root  19K sep 23 14:11 xpm3_conv.py

MLX42/web:
total 340K
drwxrwxrwx 1 root root  110 sep 23 14:11 .
drwxrwxrwx 1 root root  294 sep 23 16:05 ..
-rwxrwxrwx 1 root root 5,9K sep 23 14:11 coi-serviceworker.js
-rwxrwxrwx 1 root root 205K sep 23 14:11 demo.js
-rwxrwxrwx 1 root root 111K sep 23 14:11 demo.wasm
-rwxrwxrwx 1 root root 4,0K sep 23 14:11 index.html
-rwxrwxrwx 1 root root 5,0K sep 23 14:11 README.md

scene:
total 5,8M
drwxrwxrwx 1 root root  412 sep 23 15:40 .
drwxrwxrwx 1 root root   70 sep 23 16:06 ..
-rwxrwxrwx 1 root root  155 sep 23 14:36 basic.rt
-rwxrwxrwx 1 root root 1,4K sep 23 14:36 bonus_basic.rt
-rwxrwxrwx 1 root root 1,1K sep 23 14:11 bonus.rt
-rwxrwxrwx 1 root root  871 sep 23 14:11 home.rt
-rwxrwxrwx 1 root root  398 sep 23 14:11 ladrillo.rt
-rwxrwxrwx 1 root root 2,4K sep 23 15:09 map.rt
drwxrwxrwx 1 root root   44 sep 23 15:14 maps
-rwxrwxrwx 1 root root  455 sep 23 14:36 mir.rt
-rwxrwxrwx 1 root root 1,3K sep 23 14:11 moon.rt
-rwxrwxrwx 1 root root 1011 sep 23 14:11 new.rt
-rwxrwxrwx 1 root root 1,8K sep 23 14:11 pato.rt
-rwxrwxrwx 1 root root  222 sep 23 14:11 plane.rt
-rwxrwxrwx 1 root root 1,4K sep 23 14:11 pocoyo.rt
-rwxrwxrwx 1 root root  871 sep 23 14:11 pop.rt
-rwxrwxrwx 1 root root  356 sep 23 14:36 rock.rt
-rwxrwxrwx 1 root root  342 sep 23 14:11 scene_bonus.rt
-rwxrwxrwx 1 root root    0 sep 23 14:11 scene_empty.rt
-rwxrwxrwx 1 root root    0 sep 23 14:11 scene_wrong.rf
-rwxrwxrwx 1 root root 5,7M sep 23 14:11 sky.jpg
drwxrwxrwx 1 root root   26 sep 23 15:39 special
-rwxrwxrwx 1 root root  927 sep 23 14:11 sphere.rt
drwxrwxrwx 1 root root  800 sep 23 15:55 texture
-rwxrwxrwx 1 root root 1,2K sep 23 14:11 tink.rt
drwxrwxrwx 1 root root  238 sep 23 14:36 views
-rwxrwxrwx 1 root root  870 sep 23 15:44 water.rt

scene/maps:
total 12K
drwxrwxrwx 1 root root  44 sep 23 15:14 .
drwxrwxrwx 1 root root 412 sep 23 15:40 ..
drwxrwxrwx 1 root root 126 sep 23 14:59 figures
drwxrwxrwx 1 root root  28 sep 23 15:49 materials
drwxrwxrwx 1 root root 144 sep 23 15:35 mir
drwxrwxrwx 1 root root 110 sep 23 15:36 spc

scene/maps/figures:
total 28K
drwxrwxrwx 1 root root 126 sep 23 14:59 .
drwxrwxrwx 1 root root  44 sep 23 15:14 ..
-rwxrwxrwx 1 root root 372 sep 23 15:01 cone.rt
-rwxrwxrwx 1 root root 376 sep 23 14:54 cylinder.rt
-rwxrwxrwx 1 root root 391 sep 23 15:12 hyperboloid.rt
-rwxrwxrwx 1 root root 371 sep 23 15:04 paraboloide.rt
-rwxrwxrwx 1 root root 324 sep 23 14:53 plane.rt
-rwxrwxrwx 1 root root 318 sep 23 14:53 sphere.rt

scene/maps/materials:
total 4,0K
drwxrwxrwx 1 root root  28 sep 23 15:49 .
drwxrwxrwx 1 root root  44 sep 23 15:14 ..
-rwxrwxrwx 1 root root 283 sep 23 16:03 sphere_gold.rt

scene/maps/mir:
total 24K
drwxrwxrwx 1 root root  144 sep 23 15:35 .
drwxrwxrwx 1 root root   44 sep 23 15:14 ..
-rwxrwxrwx 1 root root 1,8K sep 23 15:25 cone_mir.rt
-rwxrwxrwx 1 root root 1,7K sep 23 15:27 cylinder_mir.rt
-rwxrwxrwx 1 root root 1,8K sep 23 15:29 hyperbolid_mir.rt
-rwxrwxrwx 1 root root 1,6K sep 23 15:33 parabolid_mir.rt
-rwxrwxrwx 1 root root 1,6K sep 23 15:26 sphere_mir.rt

scene/maps/spc:
total 20K
drwxrwxrwx 1 root root  110 sep 23 15:36 .
drwxrwxrwx 1 root root   44 sep 23 15:14 ..
-rwxrwxrwx 1 root root 1,8K sep 23 15:34 cone_spc.rt
-rwxrwxrwx 1 root root 1,7K sep 23 15:37 cylinder_spc.rt
-rwxrwxrwx 1 root root 1,7K sep 23 15:35 parabolid_spc.rt
-rwxrwxrwx 1 root root 1,7K sep 23 15:34 sphere_spc.rt

scene/special:
total 8,0K
drwxrwxrwx 1 root root   26 sep 23 15:39 .
drwxrwxrwx 1 root root  412 sep 23 15:40 ..
-rwxrwxrwx 1 root root 1,5K sep 23 14:36 room.rt
-rwxrwxrwx 1 root root  202 sep 23 15:39 spc.rt

scene/texture:
total 455M
drwxrwxrwx 1 root   root    800 sep 23 15:55 .
drwxrwxrwx 1 root   root    412 sep 23 15:40 ..
-rwxrwxrwx 1 root   root    15M sep 23 14:11 ar_color.png
-rwxrwxrwx 1 root   root    18M sep 23 14:11 ar_normal.png
-rwxrwxrwx 1 root   root   3,9M sep 23 14:11 baldosa_color_black.png
-rwxrwxrwx 1 root   root   8,6M sep 23 14:11 baldosa_normal.png
-rwxrwxrwx 1 root   root   6,0M sep 23 14:36 cuero_color.png
-rwxrwxrwx 1 root   root    27M sep 23 14:36 cuero_normal.png
-rw-r--r-- 1 cronos cronos 6,8M sep 23 15:55 gold_color.png
-rw-r--r-- 1 cronos cronos  21M sep 23 13:50 gold_normal.png
-rwxrwxrwx 1 root   root    39M sep 23 14:11 grass_color.png
-rwxrwxrwx 1 root   root    41M sep 23 14:11 grass_normal.png
-rwxrwxrwx 1 root   root    22M sep 23 14:11 ladrillo_color.png
-rwxrwxrwx 1 root   root    29M sep 23 14:11 ladrillo_normal.png
-rwxrwxrwx 1 root   root    15M sep 23 14:11 madera_color.png
-rwxrwxrwx 1 root   root    19M sep 23 14:11 madera_normal.png
-rwxrwxrwx 1 root   root    30M sep 23 14:36 oxido_color.png
-rwxrwxrwx 1 root   root    33M sep 23 14:36 oxido_normal.png
-rwxrwxrwx 1 root   root    16M sep 23 14:11 piscine_color.png
-rwxrwxrwx 1 root   root   6,0M sep 23 14:11 piscine_normal.png
-rwxrwxrwx 1 root   root    24M sep 23 14:36 rock_color.png
-rwxrwxrwx 1 root   root    35M sep 23 14:36 rock_normal.png
-rwxrwxrwx 1 root   root    12M sep 23 14:11 sky.png
-rwxrwxrwx 1 root   root   9,2M sep 23 14:11 techo_color.png
-rwxrwxrwx 1 root   root    15M sep 23 14:11 techo_normal.png
-rwxrwxrwx 1 root   root   381K sep 23 14:11 water_color.png
-rwxrwxrwx 1 root   root   430K sep 23 14:11 water_normal.png
-rwxrwxrwx 1 root   root    12M sep 23 14:11 water.png

scene/views:
total 17M
drwxrwxrwx 1 root root  238 sep 23 14:36 .
drwxrwxrwx 1 root root  412 sep 23 15:40 ..
-rwxrwxrwx 1 root root  90K sep 23 14:36 basic.png
-rwxrwxrwx 1 root root 300K sep 23 14:36 bonus_basic.png
-rwxrwxrwx 1 root root 2,7M sep 23 14:36 ladrillo.png
-rwxrwxrwx 1 root root 3,2M sep 23 14:36 map.png
-rwxrwxrwx 1 root root 4,1M sep 23 14:36 mir.png
-rwxrwxrwx 1 root root 2,9M sep 23 14:36 rock.png
-rwxrwxrwx 1 root root 861K sep 23 14:36 room.png
-rwxrwxrwx 1 root root 254K sep 23 14:36 spc.png
-rwxrwxrwx 1 root root 205K sep 23 14:36 sphere_mir.png
-rwxrwxrwx 1 root root 815K sep 23 14:36 sphere.png
-rwxrwxrwx 1 root root 197K sep 23 14:36 sphere_spc.png
-rwxrwxrwx 1 root root 1,4M sep 23 14:36 tink.png

src:
total 4,0K
drwxrwxrwx 1 root root  102 sep 23 14:11 .
drwxrwxrwx 1 root root   70 sep 23 16:06 ..
drwxrwxrwx 1 root root   52 sep 23 14:11 clean
drwxrwxrwx 1 root root  108 sep 23 14:11 inits
drwxrwxrwx 1 root root 1,5K sep 23 16:05 libft
-rwxrwxrwx 1 root root 1,8K sep 23 14:11 main.c
drwxrwxrwx 1 root root  300 sep 23 14:36 parser
drwxrwxrwx 1 root root  166 sep 23 14:11 render
drwxrwxrwx 1 root root   36 sep 23 14:11 utils
drwxrwxrwx 1 root root   16 sep 23 14:11 vector
drwxrwxrwx 1 root root   42 sep 23 14:11 windows

src/clean:
total 8,0K
drwxrwxrwx 1 root root   52 sep 23 14:11 .
drwxrwxrwx 1 root root  102 sep 23 14:11 ..
-rwxrwxrwx 1 root root 1,1K sep 23 14:11 clean_data_2.c
-rwxrwxrwx 1 root root 2,2K sep 23 14:11 clean_data.c

src/inits:
total 16K
drwxrwxrwx 1 root root  108 sep 23 14:11 .
drwxrwxrwx 1 root root  102 sep 23 14:11 ..
-rwxrwxrwx 1 root root 2,3K sep 23 14:11 init_basics.c
-rwxrwxrwx 1 root root 1,5K sep 23 14:11 init_color.c
-rwxrwxrwx 1 root root 1,8K sep 23 14:11 init_elements.c
-rwxrwxrwx 1 root root 2,1K sep 23 14:11 init_figures.c

src/libft:
total 240K
drwxrwxrwx 1 root root 1,5K sep 23 16:05 .
drwxrwxrwx 1 root root  102 sep 23 14:11 ..
-rwxrwxrwx 1 root root 1,6K sep 23 14:11 ft_atof.c
-rwxrwxrwx 1 root root 1,4K sep 23 14:11 ft_atoi.c
-rwxrwxrwx 1 root root 1,3K sep 23 14:11 ft_atol.c
-rwxrwxrwx 1 root root 1,1K sep 23 14:11 ft_bzero.c
-rwxrwxrwx 1 root root 1,2K sep 23 14:11 ft_calloc.c
-rwxrwxrwx 1 root root 1001 sep 23 14:11 ft_fabs.c
-rwxrwxrwx 1 root root 2,0K sep 23 14:11 ft_flags.c
-rwxrwxrwx 1 root root 1,3K sep 23 14:11 ft_getenv.c
-rwxrwxrwx 1 root root  979 sep 23 14:11 ft_isalnum.c
-rwxrwxrwx 1 root root  997 sep 23 14:11 ft_isalpha.c
-rwxrwxrwx 1 root root  967 sep 23 14:11 ft_isascii.c
-rwxrwxrwx 1 root root  969 sep 23 14:11 ft_isdigit.c
-rwxrwxrwx 1 root root  968 sep 23 14:11 ft_isprint.c
-rwxrwxrwx 1 root root 7,8K sep 23 14:11 ft_itoa.c
-rwxrwxrwx 1 root root 1,1K sep 23 14:11 ft_lstadd_back_bonus.c
-rwxrwxrwx 1 root root 1,1K sep 23 14:11 ft_lstadd_front_bonus.c
-rwxrwxrwx 1 root root 1,1K sep 23 14:11 ft_lstclear_bonus.c
-rwxrwxrwx 1 root root 1,1K sep 23 14:11 ft_lstdelone_bonus.c
-rwxrwxrwx 1 root root 1,1K sep 23 14:11 ft_lstiter_bonus.c
-rwxrwxrwx 1 root root 1,1K sep 23 14:11 ft_lstlast_bonus.c
-rwxrwxrwx 1 root root 1,3K sep 23 14:11 ft_lstmap_bonus.c
-rwxrwxrwx 1 root root 1,1K sep 23 14:11 ft_lstnew_bonus.c
-rwxrwxrwx 1 root root 1,1K sep 23 14:11 ft_lstsize_bonus.c
-rwxrwxrwx 1 root root 1,2K sep 23 14:11 ft_memchr.c
-rwxrwxrwx 1 root root 1,4K sep 23 14:11 ft_memcmp.c
-rwxrwxrwx 1 root root 1,2K sep 23 14:11 ft_memcpy.c
-rwxrwxrwx 1 root root 1,3K sep 23 14:11 ft_memmove.c
-rwxrwxrwx 1 root root 1,3K sep 23 14:11 ft_memset.c
-rwxrwxrwx 1 root root 1,4K sep 23 14:11 ft_printf.c
-rwxrwxrwx 1 root root 2,9K sep 23 14:11 ft_printf_utils.c
-rwxrwxrwx 1 root root  969 sep 23 14:11 ft_putchar_fd.c
-rwxrwxrwx 1 root root 1,1K sep 23 14:11 ft_putendl_fd.c
-rwxrwxrwx 1 root root 1,2K sep 23 14:11 ft_putnbr_fd.c
-rwxrwxrwx 1 root root 1006 sep 23 14:11 ft_putstr_fd.c
-rwxrwxrwx 1 root root 1,2K sep 23 14:11 ft_realloc.c
-rwxrwxrwx 1 root root 2,2K sep 23 14:11 ft_split.c
-rwxrwxrwx 1 root root 1,3K sep 23 14:11 ft_sqrt.c
-rwxrwxrwx 1 root root 1,4K sep 23 14:11 ft_strchr.c
-rwxrwxrwx 1 root root 1,1K sep 23 14:11 ft_strcmp.c
-rwxrwxrwx 1 root root 1,2K sep 23 14:11 ft_strdup.c
-rwxrwxrwx 1 root root 1,1K sep 23 14:11 ft_striteri.c
-rwxrwxrwx 1 root root 1,5K sep 23 14:11 ft_strjoin.c
-rwxrwxrwx 1 root root 1,3K sep 23 14:11 ft_strlcat.c
-rwxrwxrwx 1 root root 1,2K sep 23 14:11 ft_strlcpy.c
-rwxrwxrwx 1 root root 1,1K sep 23 14:11 ft_strlen.c
-rwxrwxrwx 1 root root 1,3K sep 23 14:11 ft_strmapi.c
-rwxrwxrwx 1 root root 1,3K sep 23 14:11 ft_strncmp.c
-rwxrwxrwx 1 root root 1,5K sep 23 14:11 ft_strnstr.c
-rwxrwxrwx 1 root root 1,4K sep 23 14:11 ft_strrchr.c
-rwxrwxrwx 1 root root 1,6K sep 23 14:11 ft_strtrim.c
-rwxrwxrwx 1 root root 2,8K sep 23 14:11 ft_substr.c
-rwxrwxrwx 1 root root 1,2K sep 23 14:11 ft_tolower.c
-rwxrwxrwx 1 root root 1,1K sep 23 14:11 ft_toupper.c
-rwxrwxrwx 1 root root 2,2K sep 23 14:11 get_next_line.c
-rwxrwxrwx 1 root root 2,3K sep 23 14:11 get_next_line_utils.c
-rwxrwxrwx 1 root root 5,0K sep 23 14:11 libft.h
-rwxrwxrwx 1 root root 2,8K sep 23 14:11 Makefile
-rwxrwxrwx 1 root root 1,6K sep 23 14:11 README.md

src/parser:
total 36K
drwxrwxrwx 1 root root  300 sep 23 14:36 .
drwxrwxrwx 1 root root  102 sep 23 14:11 ..
-rwxrwxrwx 1 root root 1020 sep 23 14:11 ft_error.c
-rwxrwxrwx 1 root root 3,1K sep 23 14:11 parser.c
-rwxrwxrwx 1 root root 4,0K sep 23 14:11 parser_elements_2.c
-rwxrwxrwx 1 root root 3,8K sep 23 14:11 parser_elements.c
-rwxrwxrwx 1 root root 2,6K sep 23 14:11 parser_utils_2.c
-rwxrwxrwx 1 root root 2,2K sep 23 14:37 parser_utils_3.c
-rwxrwxrwx 1 root root 3,3K sep 23 14:11 parser_utils.c
-rwxrwxrwx 1 root root 3,0K sep 23 14:36 parser_utils_materials_2.c
-rwxrwxrwx 1 root root 2,6K sep 23 14:11 parser_utils_materials.c

src/render:
total 36K
drwxrwxrwx 1 root root  166 sep 23 14:11 .
drwxrwxrwx 1 root root  102 sep 23 14:11 ..
drwxrwxrwx 1 root root   58 sep 23 14:11 animation
-rwxrwxrwx 1 root root 1,6K sep 23 14:11 ft_color.c
-rwxrwxrwx 1 root root 4,1K sep 23 14:11 ft_normal_mapping.c
-rwxrwxrwx 1 root root 6,5K sep 23 14:11 ft_ray.c
drwxrwxrwx 1 root root  186 sep 23 14:11 intersect
drwxrwxrwx 1 root root   90 sep 23 14:11 light
drwxrwxrwx 1 root root  220 sep 23 14:11 mapping
-rwxrwxrwx 1 root root 4,2K sep 23 14:11 render.c
-rwxrwxrwx 1 root root 4,7K sep 23 14:11 thread.c

src/render/animation:
total 8,0K
drwxrwxrwx 1 root root   58 sep 23 14:11 .
drwxrwxrwx 1 root root  166 sep 23 14:11 ..
-rwxrwxrwx 1 root root 3,0K sep 23 14:11 animate_lights.c
-rwxrwxrwx 1 root root 1,7K sep 23 14:11 auto_rotate.c

src/render/intersect:
total 40K
drwxrwxrwx 1 root root  186 sep 23 14:11 .
drwxrwxrwx 1 root root  166 sep 23 14:11 ..
-rwxrwxrwx 1 root root 4,3K sep 23 14:11 ft_cone.c
-rwxrwxrwx 1 root root 7,6K sep 23 14:11 ft_cylinder.c
-rwxrwxrwx 1 root root 2,0K sep 23 14:11 ft_cylinder_utils.c
-rwxrwxrwx 1 root root 3,9K sep 23 14:11 ft_hyperboloid.c
-rwxrwxrwx 1 root root 6,0K sep 23 14:11 ft_paraboloid.c
-rwxrwxrwx 1 root root 1,5K sep 23 14:11 ft_plane.c
-rwxrwxrwx 1 root root 2,3K sep 23 14:11 ft_sphere.c

src/render/light:
total 20K
drwxrwxrwx 1 root root   90 sep 23 14:11 .
drwxrwxrwx 1 root root  166 sep 23 14:11 ..
-rwxrwxrwx 1 root root 8,3K sep 23 14:11 ft_light.c
-rwxrwxrwx 1 root root 3,1K sep 23 14:11 ft_light_utils.c
-rwxrwxrwx 1 root root 3,6K sep 23 14:11 ft_specular_light.c

src/render/mapping:
total 28K
drwxrwxrwx 1 root root  220 sep 23 14:11 .
drwxrwxrwx 1 root root  166 sep 23 14:11 ..
-rwxrwxrwx 1 root root 2,2K sep 23 14:11 ft_texture.c
-rwxrwxrwx 1 root root 1,6K sep 23 14:11 get_uv_cone.c
-rwxrwxrwx 1 root root 1,7K sep 23 14:11 get_uv_cylinder.c
-rwxrwxrwx 1 root root 1,6K sep 23 14:11 get_uv_hyperboloid.c
-rwxrwxrwx 1 root root 2,7K sep 23 14:11 get_uv_paraboloid.c
-rwxrwxrwx 1 root root 2,6K sep 23 14:11 get_uv_plane.c
-rwxrwxrwx 1 root root 1,3K sep 23 14:11 get_uv_sphere.c

src/utils:
total 8,0K
drwxrwxrwx 1 root root   36 sep 23 14:11 .
drwxrwxrwx 1 root root  102 sep 23 14:11 ..
-rwxrwxrwx 1 root root 1,1K sep 23 14:11 nthreads.c
-rwxrwxrwx 1 root root 1019 sep 23 14:11 ray_at.c

src/vector:
total 0
drwxrwxrwx 1 root root  16 sep 23 14:11 .
drwxrwxrwx 1 root root 102 sep 23 14:11 ..
drwxrwxrwx 1 root root 100 sep 23 14:11 vec2
drwxrwxrwx 1 root root 340 sep 23 14:11 vec3

src/vector/vec2:
total 16K
drwxrwxrwx 1 root root  100 sep 23 14:11 .
drwxrwxrwx 1 root root   16 sep 23 14:11 ..
-rwxrwxrwx 1 root root 1008 sep 23 14:11 vec2_dot.c
-rwxrwxrwx 1 root root 1,0K sep 23 14:11 vec2_init.c
-rwxrwxrwx 1 root root  997 sep 23 14:11 vec2_length.c
-rwxrwxrwx 1 root root 1,1K sep 23 14:11 vec2_normalize.c

src/vector/vec3:
total 52K
drwxrwxrwx 1 root root  340 sep 23 14:11 .
drwxrwxrwx 1 root root   16 sep 23 14:11 ..
-rwxrwxrwx 1 root root 1,6K sep 23 14:11 ft_rotate_vector.c
-rwxrwxrwx 1 root root 1,1K sep 23 14:11 vec3_add.c
-rwxrwxrwx 1 root root 1,1K sep 23 14:11 vec3_cross.c
-rwxrwxrwx 1 root root 1,1K sep 23 14:11 vec3_div.c
-rwxrwxrwx 1 root root 1023 sep 23 14:11 vec3_dot.c
-rwxrwxrwx 1 root root 1,1K sep 23 14:11 vec3_init.c
-rwxrwxrwx 1 root root  995 sep 23 14:11 vec3_length.c
-rwxrwxrwx 1 root root  997 sep 23 14:11 vec3_length_squared.c
-rwxrwxrwx 1 root root 1,1K sep 23 14:11 vec3_mul.c
-rwxrwxrwx 1 root root 1,1K sep 23 14:11 vec3_mult_vec.c
-rwxrwxrwx 1 root root 1,1K sep 23 14:11 vec3_normalize.c
-rwxrwxrwx 1 root root 1,1K sep 23 14:11 vec3_reflect.c
-rwxrwxrwx 1 root root 1,1K sep 23 14:11 vec3_sub.c

src/windows:
total 16K
drwxrwxrwx 1 root root   42 sep 23 14:11 .
drwxrwxrwx 1 root root  102 sep 23 14:11 ..
-rwxrwxrwx 1 root root 5,1K sep 23 14:11 hook.c
-rwxrwxrwx 1 root root 1,3K sep 23 14:11 mouse.c
-rwxrwxrwx 1 root root 1,9K sep 23 14:11 window.c
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minirt.h                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rmarrero  <marvin@42.fr>                   +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 14:22:49 by rmarrero          #+#    #+#             */
/*   Updated: 2025/07/23 14:23:20 by rmarrero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#ifndef MINIRT_H
# define MINIRT_H

// --- 0. Includes de Librerías ---
# include "../MLX42/include/MLX42/MLX42.h"
# include "../src/libft/libft.h"
# include <X11/X.h>
# include <X11/Xlib.h>
# include <X11/keysym.h>
# include <errno.h>
# include <math.h>
# include <pthread.h>
# include <stdlib.h>

// --- 1. Constantes y Macros ---
# define EPSILON 1e-6
# ifndef M_PI
#  define M_PI 3.14159265358979323846
# endif
# define MAX_RECURSION_DEPTH 5
# define MOUSE_MOVE_THRESHOLD 0.5
# define MOVE_SPEED 0.5
# define ROTATION_SPEED 0.05
# define EISDIR 21

// -- quality 4k 8k  -- //
# define SUBPIXEL_SAMPLES 2
# define KEY_W XK_w
# define KEY_A XK_a
# define KEY_S XK_s
# define KEY_D XK_d
# define KEY_ESC XK_Escape

// --- 2. Macros de Errores ---
# define ERR_TOO_MANY_ARGS "Error\nToo many arguments.\n"
# define ERR_INVALID_FILE "Error\nInvalid file or path.\n"
# define ERR_INVALID_EXT "Error\nInvalid file extension. Use .rt\n"
# define ERR_INVALID_LINE "Error\nInvalid line in .rt file.\n"
# define ERR_MISSING_ELEMENT "Error\nMissing mandatory element (A, C).\n"
# define ERR_DUPLICATE_ELEMENT "Error\nDuplicate mandatory element (A, C).\n"
# define ERR_INVALID_PARAMS "Error\nInvalid parameters for element.\n"
# define ERR_MEMORY "Error\nMemory allocation failed.\n"

# define WIDTH_8K 7680
# define HEIGHT_8K 4320
# define WIDTH_4K 3840
# define HEIGHT_4K 2160

// --- 3. Estructuras de Datos Primarias ---

// Vector y color
typedef struct s_vec2
{
	double			x;
	double			y;
}					t_vec2;

typedef struct s_vec3
{
	double			x;
	double			y;
	double			z;
}					t_vec3;

typedef struct s_mat3
{
	t_vec3			c1;
	t_vec3			c2;
	t_vec3			c3;
}					t_mat3;

typedef t_vec3		t_color;

// Rayo
typedef struct s_ray
{
	t_vec3			origin;
	t_vec3			direction;
}					t_ray;

// Información de un impacto (hit)
typedef struct s_hit_record
{
	t_vec3			point;
	t_vec3			normal;
	double			t;
	t_ray			ray;
	struct s_object	*object;
}					t_hit_record;

// Parámetros de especularidad (modelo de Phong)
typedef struct s_specular
{
	float			intensity;
	int				shininess;
}					t_specular;

typedef struct s_material
{
	t_specular		specular;
	double			mirror_ratio;
	bool			has_texture;
	mlx_texture_t	*color_img;
	bool			has_normal_map;
	mlx_texture_t	*texture_img;
	int				has_checkerboard;
	t_vec3			check_color1;
	t_vec3			check_color2;
	double			check_scale;
}					t_material;

typedef struct s_texture
{
	int				is_checkerboard;
	int				is_bump_map;
	char			*file_path;
}					t_texture;

// --- 4. Estructuras de Elementos de la Escena ---

// Cámara
typedef struct s_camera
{
	t_vec3			position;
	t_vec3			orientation;
	double			fov;
	t_vec3			forward;
	t_vec3			right;
	t_vec3			up;
}					t_camera;

// Luces
typedef struct s_ambient_light
{
	double			ratio;
	t_vec3			color;
}					t_ambient_light;

typedef enum e_movement_type
{
	MOVEMENT_NONE,
	MOVEMENT_CIRCLE,
	MOVEMENT_TRIANGLE,
	MOVEMENT_LINE
}					t_movement_type;

typedef struct s_light
{
	t_vec3			position;
	double			brightness;
	t_color			color;
	bool			is_moving;
	t_movement_type	movement_type;
}					t_light;

typedef enum e_object_type
{
	SPHERE,
	PLANE,
	CYLINDER,
	CONE,
	HYPERBOLOID,
	PARABOLOID,
}					t_object_type;

// Esfera
typedef struct s_sphere
{
	t_vec3			center;
	double			radius;
}					t_sphere;

// Plano
typedef struct s_plane
{
	t_vec3			position;
	t_vec3			normal;
}					t_plane;

// Cilindro
typedef struct s_cylinder
{
	t_vec3			position;
	t_vec3			axis;
	double			radius;
	double			height;
}					t_cylinder;

// Cono (bonificación)
typedef struct s_cone
{
	t_vec3			position;
	t_vec3			axis;
	double			radius;
	double			height;
}					t_cone;

// Hiperboloide (bonificación)
typedef struct s_hyperboloid
{
	t_vec3			position;
	t_vec3			axis;
	double			radius_a;
	double			radius_b;
	double			height;
}					t_hyperboloid;

typedef struct s_parab
{
	t_vec3			position;
	t_vec3			axis;
	double			focal_lenght;
	double			height;
}					t_parab;

// Objeto genérico - Ahora más limpio con la nueva estructura de material
typedef struct s_object
{
	t_object_type	type;
	t_vec3			color;
	void			*data;
	t_material		*material;
}					t_object;

// --- 5. Estructuras de Control del Programa ---

// Escena
typedef struct s_scene
{
	t_ambient_light	ambient;
	t_camera		camera;
	t_light			**lights;
	t_object		**objects;
	int				width;
	int				height;
	int				has_camera;
	int				has_ambient;
	t_color			background_color;
	int				num_lights;
}					t_scene;

// Minilibx y la imagen
typedef struct s_img
{
	char			*addr;
	void			*img_ptr;
	int				bpp;
	int				line_len;
	int				endian;
	int				width;
	int				height;
}					t_img;

typedef struct s_mlx
{
	void			*mlx_ptr;
	void			*win_ptr;
	t_img			img;
}					t_mlx;

typedef struct s_mouse_state
{
	bool			is_pressed;
	double			last_x;
	double			last_y;
}					t_mouse_state;

// Datos globales para la multihilo
typedef struct s_data
{
	t_mlx			mlx;
	t_scene			scene;
	int				num_threads;
	int				rendered_rows;
	int				show_progress;
	pthread_mutex_t	progress_mutex;
	unsigned long	ray_count;
	t_mouse_state	mouse_state;
	bool			auto_rotate_active;
	double			rotation_angle;
	t_vec3			rotation_center;
	double			light_move_time;
}					t_data;

// Datos específicos del hilo
typedef struct s_thread_data
{
	int				id;
	int				start_row;
	int				end_row;
	t_data			*global_data;
}					t_thread_data;

// Struct for passing multiple context variables to functions
typedef struct s_light_context
{
	t_hit_record	*rec;
	t_scene			*scene;
	t_ray			*ray;
	t_vec3			effective_normal;
}					t_light_context;

t_color				calculate_direct_lighting(t_hit_record *rec, t_scene *scene,
						t_ray *ray, t_vec3 effective_normal);
t_color				get_light_contribution(t_light_context *ctx,
						t_light *light);
t_vec3				get_effective_normal(t_hit_record *rec);
t_color				clamp_color(t_color color);
t_color				calculate_ambient_light(t_hit_record *rec, t_scene *scene);
t_color				calculate_diffuse_light(t_hit_record *rec, t_light *light,
						t_vec3 effective_normal, t_vec3 to_light);

// src/intersect/ft_cone.c
typedef struct s_cone_params
{
	t_vec3			oc;
	double			a;
	double			b;
	double			c;
}					t_cone_params;

typedef struct s_subpixel_data
{
	int				x;
	int				y;
	int				sub_x;
	int				sub_y;
}					t_subpixel_data;

typedef struct s_ray_data
{
	t_vec3			camera_right;
	t_vec3			camera_up;
	double			fov_rad;
	double			aspect_ratio;
	double			x_coord_normalized;
	double			y_coord_normalized;
	t_vec3			viewport_center;
}					t_ray_data;

typedef struct s_thread_init_data
{
	t_thread_data	*td;
	int				i;
	int				rows_per_thread;
	int				*start_row;
}					t_thread_init_data;

typedef struct s_hit_params
{
	t_ray			*ray;
	t_cylinder		*cy;
	t_vec3			oc;
}					t_hit_params;

typedef struct s_closest_hit_data
{
	t_hit_record	side_hit;
	t_hit_record	cap_hit;
	int				side_found;
	int				cap_found;
}					t_closest_hit_data;

t_vec3				calculate_quadratic_coeffs(t_ray *ray, t_vec3 oc,
						t_cylinder *cy);
int					check_hit_and_update_rec(t_hit_params *params,
						t_hit_record *rec, double t_side);
// --- Function Prototypes ---

// Math Functions
double				ft_fmin(double x, double y);
double				ft_fmod(double x, double y);
double				ft_pow(double base, double exp);

// Vector 2 Functions
t_vec2				vec2_init(double x, double y);
t_vec2				vec2_normalize(t_vec2 v);

// Vector 3 Functions
t_vec3				vec3_init(double x, double y, double z);
t_vec3				vec3_cross(t_vec3 v1, t_vec3 v2);
t_vec3				vec3_add(t_vec3 v1, t_vec3 v2);
t_vec3				vec3_sub(t_vec3 v1, t_vec3 v2);
t_vec3				vec3_mul(t_vec3 v, double scalar);
t_vec3				vec3_div(t_vec3 v, double scalar);
t_vec3				vec3_mult_vec(t_vec3 v1, t_vec3 v2);
double				vec3_dot(t_vec3 v1, t_vec3 v2);
t_vec3				vec3_cross(t_vec3 v1, t_vec3 v2);
double				vec3_length(t_vec3 v);
double				vec3_length_squared(t_vec3 v);
t_vec3				vec3_normalize(t_vec3 v);
t_vec3				vec3_reflect(t_vec3 v, t_vec3 n);

t_vec3				rotate_vector(t_vec3 v, t_vec3 axis, double angle);

// --- 6. Funciones de Renderizado y MLX ---
int					mlx_setup(t_data *data);
int					close_window(t_data *data);
void				key_hook(mlx_key_data_t keydata, void *param);
int					mouse_press(int button, int x, int y, t_data *data);
int					mouse_release(int button, int x, int y, t_data *data);
int					mouse_move(int x, int y, t_data *data);
void				render_threaded(t_data *data);
void				*thread_render_rows(void *arg);
void				put_pixel_to_img(t_img *img, int x, int y, int color);

// --- 7. Funciones de Utilidad del Ray Tracer ---
t_ray				generate_ray(int x, int y, t_scene *scene);
t_hit_record		find_closest_hit(t_ray *ray, t_scene *scene);
int					color_to_int(t_color color);
t_vec3				apply_bump_map(t_hit_record *rec, t_object *obj);
t_color				calculate_light(t_hit_record *rec, t_scene *scene,
						t_ray *ray, int depth);
t_color				get_texture_color(t_hit_record *rec);
t_ray				generate_antialiased_ray(t_subpixel_data sp,
						t_scene *scene);
t_vec3				get_normal_from_map(t_hit_record *rec, t_vec3 geom_normal);
t_vec2				get_uv_sphere(t_hit_record *rec);
t_vec2				get_uv_plane(t_hit_record *rec);
t_vec2				get_uv_cylinder(t_hit_record *rec);
t_vec2				get_uv_cone(t_hit_record *rec);
t_vec2				get_uv_hyperboloid(t_hit_record *rec);
t_vec2				get_uv_paraboloid(t_hit_record *rec);

// --- 8. Funciones de Intersección (incluye bonificaciones) ---
int					intersect_sphere(t_ray *ray, t_sphere *sp,
						t_hit_record *rec);
int					intersect_plane(t_ray *ray, t_plane *pl, t_hit_record *rec);
int					intersect_cylinder(t_ray *ray, t_cylinder *cy,
						t_hit_record *rec);
int					intersect_cone(t_ray *ray, t_cone *co, t_hit_record *rec);
int					intersect_hyperboloid(t_ray *ray, t_hyperboloid *hb,
						t_hit_record *rec);
int					intersect_paraboloid(t_ray *ray, t_parab *pb,
						t_hit_record *rec);

// --- 9. Funciones del Parser (incluye bonificaciones) ---
void				apply_object_modifiers(t_object *obj, char **tokens,
						int start_idx);
int					open_filename(const char *filename);
int					valid_extension_rt(const char *file_name);
int					validate_texture_extension(const char *file_name);
void				validate_file(int fd, const char *file_name);
double				parse_fov(char *str);
double				parse_mirror(char *token);
double				parse_angle(char *str);
double				parse_positive_double(char *str);
double				validate_color_component(char *str);
void				parse_specular(char *token, t_specular *spec);
void				parse_checkboard(char *token, t_material *material);
void				parse_rt_file(t_scene *scene, const char *file_path);
void				parse_ambient(t_scene *scene, char **tokens);
void				parse_camera(t_scene *scene, char **tokens);
void				parse_light(t_scene *scene, char **tokens);
void				parse_sphere(t_scene *scene, char **tokens);
void				parse_plane(t_scene *scene, char **tokens);
void				parse_cylinder(t_scene *scene, char **tokens);
void				parse_cone(t_scene *scene, char **tokens);
void				parse_hyperboloid(t_scene *scene, char **tokens);
void				parse_paraboloid(t_scene *scene, char **tokens);
t_vec3				parse_vec3(char *str);
t_vec3				parse_vec3_color(char *str);
t_vec3				parse_vec3_normalized(char *str);
t_object			*create_object(t_object_type type, void *data,
						t_vec3 color);

// --- 10. Funciones de Inicialización ---
t_vec3				vec3_init(double x, double y, double z);
t_ray				ray_init(t_vec3 origin, t_vec3 direction);
t_camera			camera_init(t_vec3 position, t_vec3 orientation,
						double fov);
t_ambient_light		ambient_light_init(double ratio, t_vec3 color);
t_light				light_init(t_vec3 position, double brightness,
						t_vec3 color);
t_sphere			sphere_init(t_vec3 center, double radius);
t_plane				plane_init(t_vec3 position, t_vec3 normal);
t_cylinder			cylinder_init(t_vec3 position, t_vec3 axis, double radius,
						double height);
t_cone				cone_init(t_vec3 position, t_vec3 axis, double radius,
						double height);
t_hyperboloid		hyperboloid_init(t_vec3 position, t_vec3 axis);

// --- 11. Funciones a Mover a Libft / Utilidades Generales ---

t_vec2				vec2_init(double x, double y);
t_vec3				vec3_add(t_vec3 v1, t_vec3 v2);
t_vec3				vec3_sub(t_vec3 v1, t_vec3 v2);
t_vec3				vec3_mul(t_vec3 v, double scalar);
t_vec3				vec3_div(t_vec3 v, double scalar);
t_vec3				vec3_mult_vec(t_vec3 v1, t_vec3 v2);
double				vec3_dot(t_vec3 v1, t_vec3 v2);
t_vec3				vec3_cross(t_vec3 v1, t_vec3 v2);
double				vec3_length(t_vec3 v);
t_vec3				vec3_normalize(t_vec3 v);
t_vec3				ray_at(t_ray r, double t);
t_vec3				vec3_reflect(t_vec3 v, t_vec3 n);
t_vec3				rotate_vector(t_vec3 v, t_vec3 axis, double angle);

void				validate_args(int argc, char **argv);
int					is_valid_float(char *str);
int					is_valid_int(char *str);
int					is_valid_color_component(char *str);
int					is_normalized_vector(t_vec3 vec);
void				ft_error_exit(const char *msg);
void				add_object_to_scene(t_scene *scene, t_object *obj);
void				add_light_to_scene(t_scene *scene, t_light *light);
int					ft_strarr_len(char **arr);
double				ft_atod(const char *str);
void				ft_free_str_array(char **arr);
void				free_tokens(char **tokens);
void				free_scene_data(t_scene *scene);
void				cleanup_program(t_data *data);
int					is_in_shadow(t_ray *shadow_ray, t_scene *scene,
						t_light *light);
void				init_scene(t_scene *scene);
int					get_num_processors(void);
void				mouse_move_hook(double x, double y, void *param);
// In src/windows/../../include/minirt.h
void				mouse_press_hook(mouse_key_t button, action_t action,
						modifier_key_t modifier, void *param);
t_color				calculate_specular_light(t_hit_record *rec, t_light *light,
						t_ray *ray);
t_color				get_object_color(t_hit_record *rec);
void				animate_lights(void *param);
void				auto_rotate(void *param);
double				vec3_length_squared(t_vec3 v);
void				render_threaded(t_data *data);
void				*render_thread_func(void *arg);
void				ft_zoom(t_data *data, double zoom_factor);
void				ft_error_exit(const char *msg);
t_vec2				get_texture_uv(t_hit_record *rec);

#endif